-- phpMyAdmin SQL Dump
-- version 5.2.0
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Мар 19 2024 г., 15:57
-- Версия сервера: 8.0.30
-- Версия PHP: 7.2.34

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `content2`
--

-- --------------------------------------------------------

--
-- Структура таблицы `article`
--

CREATE TABLE `article` (
  `id` int NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `genre` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Дамп данных таблицы `article`
--

INSERT INTO `article` (`id`, `title`, `genre`, `image`, `description`) VALUES
(1, 'Возможности языка Python', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fcdn.dribbble.com%2Fusers%2F1103017%2Fscreenshots%2F4307976%2Fad-01-.jpg&f=1&nofb=1&ipt=6a4ebf5d04759f0910e136176a54ad464fb23f57ed16bff215a8cacedf024e81&ipo=images', 'Так как мне часто стали задавать вопросы о том, чем может быть полезен Python, я решил написать небольшую обзорную статью на эту тему.\nВот лишь некоторые вещи, которые умеет делать Python: Работа с xml/html файлами, работа с http запросами, GUI (графический интерфейс), создание веб-сценариев, работа с FTP, работа с изображениями, аудио и видео файлами, робототехника, программирование математических и научных вычислений и многое, многое другое...\nТаким образом, Python подходит для решения львиной доли повседневных задач, будь то резервное копирование, чтение электронной почты, либо же какая-нибудь игрушка. Язык программирования Python практически ничем не ограничен, поэтому также может использоваться в крупных проектах. К примеру, Python интенсивно применяется IT-гигантами, такими как, например, Google и Yandex. К тому же простота и универсальность python делают его одним из лучших языков программирования.'),
(2, 'Введение в JavaScript', 'JavaScript', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.programaenlinea.net%2Fwp-content%2Fuploads%2F2019%2F02%2Fjavascript-3.jpg&f=1&nofb=1&ipt=58d7b98645bd166a0482ad5790ed7bfe84b330a36d83577b53b9dbb2e87b658f&ipo=images', 'Введение в JavaScript\n\nДавайте посмотрим, что такого особенного в JavaScript, чего можно достичь с его помощью и какие другие технологии хорошо с ним работают.\nЧто такое JavaScript?\n\nИзначально JavaScript был создан, чтобы «сделать веб-страницы живыми».\n\nПрограммы на этом языке называются скриптами. Они могут встраиваться в HTML и выполняться автоматически при загрузке веб-страницы.\n\nСкрипты распространяются и выполняются, как простой текст. Им не нужна специальная подготовка или компиляция для запуска.\n\nЭто отличает JavaScript от другого языка – Java.\nПочему JavaScript?\n\nКогда JavaScript создавался, у него было другое имя – «LiveScript». Однако, язык Java был очень популярен в то время, и было решено, что позиционирование JavaScript как «младшего брата» Java будет полезно.\n\nСо временем JavaScript стал полностью независимым языком со своей собственной спецификацией, называющейся ECMAScript, и сейчас не имеет никакого отношения к Java.\n\nСегодня JavaScript может выполняться не только в браузере, но и на сервере или на любом другом устройстве, которое имеет специальную программу, называющуюся «движком» JavaScript.\n\nУ браузера есть собственный движок, который иногда называют «виртуальная машина JavaScript».\n\nРазные движки имеют разные «кодовые имена». Например:\n\n    V8 – в Chrome, Opera и Edge.\n    SpiderMonkey – в Firefox.\n    …Ещё есть «Chakra» для IE, «JavaScriptCore», «Nitro» и «SquirrelFish» для Safari и т.д.\n\nЭти названия полезно знать, так как они часто используются в статьях для разработчиков. Мы тоже будем их использовать. Например, если «функциональность X поддерживается V8», тогда «Х», скорее всего, работает в Chrome, Opera и Edge.\nКак работают движки?\n\nДвижки сложны. Но основы понять легко.\n\n    Движок (встроенный, если это браузер) читает («парсит») текст скрипта.\n    Затем он преобразует («компилирует») скрипт в машинный язык.\n    После этого машинный код запускается и работает достаточно быстро.\n\nДвижок применяет оптимизации на каждом этапе. Он даже просматривает скомпилированный скрипт во время его работы, анализируя проходящие через него данные, и применяет оптимизации к машинному коду, полагаясь на полученные знания. В результате скрипты работают очень быстро.\nЧто может JavaScript в браузере?\n\nСовременный JavaScript – это «безопасный» язык программирования. Он не предоставляет низкоуровневый доступ к памяти или процессору, потому что изначально был создан для браузеров, не требующих этого.\n\nВозможности JavaScript сильно зависят от окружения, в котором он работает. Например, Node.JS поддерживает функции чтения/записи произвольных файлов, выполнения сетевых запросов и т.д.\n\nВ браузере для JavaScript доступно всё, что связано с манипулированием веб-страницами, взаимодействием с пользователем и веб-сервером.\n\nНапример, в браузере JavaScript может:\n\n    Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.\n    Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.\n    Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).\n    Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.\n    Запоминать данные на стороне клиента («local storage»).\n\nЧего НЕ может JavaScript в браузере?\n\nВозможности JavaScript в браузере ограничены ради безопасности пользователя. Цель заключается в предотвращении доступа недобросовестной веб-страницы к личной информации или нанесения ущерба данным пользователя.\n\nПримеры таких ограничений включают в себя:\n\n    JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.\n\n    Современные браузеры позволяют ему работать с файлами, но с ограниченным доступом, и предоставляют его, только если пользователь выполняет определённые действия, такие как «перетаскивание» файла в окно браузера или его выбор с помощью тега <input>.\n\n    Существуют способы взаимодействия с камерой/микрофоном и другими устройствами, но они требуют явного разрешения пользователя. Таким образом, страница с поддержкой JavaScript не может незаметно включить веб-камеру, наблюдать за происходящим и отправлять информацию в ФСБ.\n\n    Различные окна/вкладки не знают друг о друге. Иногда одно окно, используя JavaScript, открывает другое окно. Но даже в этом случае JavaScript с одной страницы не имеет доступа к другой, если они пришли с разных сайтов (с другого домена, протокола или порта).\n\n    Это называется «Политика одинакового источника» (Same Origin Policy). Чтобы обойти это ограничение, обе страницы должны согласиться с этим и содержать JavaScript-код, который специальным образом обменивается данными.\n\n    Это ограничение необходимо, опять же, для безопасности пользователя. Страница https://anysite.com, которую открыл пользователь, не должна иметь доступ к другой вкладке браузера с URL https://gmail.com и воровать информацию оттуда.\n\n    JavaScript может легко взаимодействовать с сервером, с которого пришла текущая страница. Но его способность получать данные с других сайтов/доменов ограничена. Хотя это возможно в принципе, для чего требуется явное согласие (выраженное в заголовках HTTP) с удалённой стороной. Опять же, это ограничение безопасности.\n\nПодобные ограничения не действуют, если JavaScript используется вне браузера, например — на сервере. Современные браузеры предоставляют плагины/расширения, с помощью которых можно запрашивать дополнительные разрешения.\nЧто делает JavaScript особенным?\n\nКак минимум, три сильные стороны JavaScript:\n\n    Полная интеграция с HTML/CSS.\n    Простые вещи делаются просто.\n    Поддерживается всеми основными браузерами и включён по умолчанию.\n\nJavaScript – это единственная браузерная технология, сочетающая в себе все эти три вещи.\n\nВот что делает JavaScript особенным. Вот почему это самый распространённый инструмент для создания интерфейсов в браузере.\n\nХотя, конечно, JavaScript позволяет делать приложения не только в браузерах, но и на сервере, на мобильных устройствах и т.п.\nЯзыки «над» JavaScript\n\nСинтаксис JavaScript подходит не под все нужды. Разные люди хотят иметь разные возможности.\n\nЭто естественно, потому что проекты разные и требования к ним тоже разные.\n\nТак, в последнее время появилось много новых языков, которые транспилируются (конвертируются) в JavaScript, прежде чем запустятся в браузере.\n\nСовременные инструменты делают транспиляцию очень быстрой и прозрачной, фактически позволяя разработчикам писать код на другом языке, автоматически преобразуя его в JavaScript «под капотом».\n\nПримеры таких языков:\n\n    CoffeeScript добавляет «синтаксический сахар» для JavaScript. Он вводит более короткий синтаксис, который позволяет писать чистый и лаконичный код. Обычно такое нравится Ruby-программистам.\n    TypeScript концентрируется на добавлении «строгой типизации» для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft.\n    Flow тоже добавляет типизацию, но иначе. Разработан Facebook.\n    Dart стоит особняком, потому что имеет собственный движок, работающий вне браузера (например, в мобильных приложениях). Первоначально был предложен Google, как замена JavaScript, но на данный момент необходима его транспиляция для запуска так же, как для вышеперечисленных языков.\n    Brython транспилирует Python в JavaScript, что позволяет писать приложения на чистом Python без JavaScript.\n\nЕсть и другие. Но даже если мы используем один из этих языков, мы должны знать JavaScript, чтобы действительно понимать, что мы делаем.\nИтого\n\n    JavaScript изначально создавался только для браузера, но сейчас используется на многих других платформах.\n    Сегодня JavaScript занимает уникальную позицию в качестве самого распространённого языка для браузера, обладающего полной интеграцией с HTML/CSS.\n    Многие языки могут быть «транспилированы» в JavaScript для предоставления дополнительных функций. Рекомендуется хотя бы кратко рассмотреть их после освоения JavaScript.\n\n'),
(3, 'Язык C# и платформа .NET', 'C#', 'https://i.imgur.com/LzI2d3d.png', 'На сегодняшний момент язык программирования C# один из самых мощных, быстро развивающихся и востребованных языков в ИТ-отрасли. В настоящий момент на нем пишутся самые различные приложения: от небольших десктопных программок до крупных веб-порталов и веб-сервисов, обслуживающих ежедневно миллионы пользователей.\n\nC# уже не молодой язык и как и вся платформа .NET уже прошел большой путь. Первая версия языка вышла вместе с релизом Microsoft Visual Studio .NET в феврале 2002 года. Текущей версией языка является версия C# 12, которая вышла 14 ноября 2023 года вместе с релизом .NET 8.\n\nC# является языком с Си-подобным синтаксисом и близок в этом отношении к C++ и Java. Поэтому, если вы знакомы с одним из этих языков, то овладеть C# будет легче.\n\nC# является объектно-ориентированным и в этом плане много перенял у Java и С++. Например, C# поддерживает полиморфизм, наследование, перегрузку операторов, статическую типизацию. Объектно-ориентированный подход позволяет решить задачи по построению крупных, но в тоже время гибких, масштабируемых и расширяемых приложений. И C# продолжает активно развиваться, и с каждой новой версией появляется все больше интересных функциональностей.\nРоль платформы .NET\n\nКогда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, .NET MAUI). И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире.\n\nКак-то Билл Гейтс сказал, что платформа .NET - это лучшее, что создала компания Microsoft. Возможно, он был прав. Фреймворк .NET представляет мощную платформу для создания приложений. Можно выделить следующие ее основные черты:\n\n    Поддержка нескольких языков. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), благодаря чему .NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы .NET. Поэтому при определенных условиях мы можем сделать отдельные модули одного приложения на отдельных языках.\n\n    Кроссплатформенность. .NET является переносимой платформой (с некоторыми ограничениями). Например, последняя версия платформы на данный момент - .NET 8 поддерживается на большинстве современных ОС Windows, MacOS, Linux. Используя различные технологии на платформе .NET, можно разрабатывать приложения на языке C# для самых разных платформ - Windows, MacOS, Linux, Android, iOS, Tizen.\n\n    Мощная библиотека классов. .NET представляет единую для всех поддерживаемых языков библиотеку классов. И какое бы приложение мы не собирались писать на C# - текстовый редактор, чат или сложный веб-сайт - так или иначе мы задействуем библиотеку классов .NET.\n\n    Разнообразие технологий. Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, для работы с базами данных в этом стеке технологий предназначена технология ADO.NET и Entity Framework Core. Для построения графических приложений с богатым насыщенным интерфейсом - технология WPF и WinUI, для создания более простых графических приложений - Windows Forms. Для разработки кроссплатформенных мобильных и десктопных приложений - Xamarin/MAUI. Для создания веб-сайтов и веб-приложений - ASP.NET и т.д.\n\n    К этому стоит добавить активной развивающийся и набирающий популяность Blazor - фреймворк, который работает поверх .NET и который позволяет создавать веб-приложения как на стороне сервера, так и на стороне клиента. А в будущем будет поддерживать создание мобильных приложений и, возможно, десктоп-приложений.\n\n    Производительность. Согласно ряду тестов веб-приложения на .NET в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий. Приложения на .NET в принципе отличаются высокой производительностью.\n\nТакже еще следует отметить такую особенность языка C# и фреймворка .NET, как автоматическая сборка мусора. А это значит, что нам в большинстве случаев не придется, в отличие от С++, заботиться об освобождении памяти. Вышеупомянутая общеязыковая среда CLR сама вызовет сборщик мусора и очистит память.\n.NET Framework и .NET 8\n\nСтоит отметить, что .NET долгое время развивался премущественно как платформа для Windows под названием .NET Framework. В 2019 вышла последняя версия этой платформы - .NET Framework 4.8. Она больше не развивается\n\nС 2014 Microsoft стал развивать альтернативную платформу - .NET Core, которая уже предназначалась для разных платформ и должна была вобрать в себя все возможности устаревшего .NET Framework и добавить новую функциональность. Затем Microsoft последовательно выпустил ряд версий этой платформы: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. И текущей версией является расматриваемая в этом руководстве платформа .NET 8. Поэтому следует различать .NET Framework, который предназначен преимущественно для Windows, и кросплатформенный .NET 8. В данном руководстве речь будет идти о C# 12 в связке с .NET 8, поскольку это актуальная платформа.\nУправляемый и неуправляемый код\n\nНередко приложение, созданное на C#, называют управляемым кодом (managed code). Что это значит? А это значит, что данное приложение создано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память. Но есть также приложения, например, созданные на языке С++, которые компилируются не в общий язык CIL, как C#, VB.NET или F#, а в обычный машинный код. В этом случае .NET не управляет приложением.\n\nВ то же время платформа .NET предоставляет возможности для взаимодействия с неуправляемым кодом..\nJIT-компиляция\n\nКак выше писалось, код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения происходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и содержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если мы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения работы программы. В итоге это повышает производительность.\n\nПо сути это все, что вкратце надо знать о платформе .NET и языке C#. А теперь создадим первое приложение.'),
(4, 'Скачивание и установка Python', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftechdecodetutorials.com%2Fwp-content%2Fuploads%2F2021%2F07%2Fthumbnail_python.png&f=1&nofb=1&ipt=5261a6d34376ee9f75895d765ed18bbb0d1760dc34dce5afd0b21be39716920d&ipo=images', 'Скачивать python будем с официального сайта. Кстати, не рекомендую скачивать интерпретатор python с других сайтов или через торрент, в них могут быть вирусы. Программа бесплатная. Заходим на https://python.org/downloads/windows/, выбираем \"latest python release\" и python 3. Появляется страница с описанием данной версии Python (на английском). Если интересно - можете почитать. Затем крутим в самый низ страницы, а затем открываем \"download page\". Вы увидите список файлов, которые можно загрузить. Нам нужен Windows x86 MSI installer (если система 32-х битная), или Windows x86-64 MSI installer (если система 64-х битная). Больше из файлов нам ничего не нужно. Ждём, пока python загрузится. Затем открываем загрузившийся файл. Файл подписан Python Software Foundation, значит, все в порядке. Пользуясь случаем, напоминаю, что не стоит открывать незнакомые exe файлы. Устанавливаем для всех пользователей или только для одного (на ваше усмотрение). Выбираем папку для установки. Я оставляю папку по умолчанию. Вы можете выбрать любую папку на своем диске. Выбираем компоненты, которые будут установлены. Оставьте компоненты по умолчанию, если не уверены. Ждем установки python...\n\nFinish. Поздравляю, вы установили Python! Также в установщик python для windows встроена среда разработки IDLE. Прямо сейчас вы можете написать свою первую программу!'),
(5, 'Первая программа', 'Python', 'https://i.imgur.com/owHbzlm.png', 'Сегодня мы напишем свою первую программу в среде разработки IDLE.\n\nПосле загрузки и установки python открываем IDLE (среда разработки на языке Python, поставляемая вместе с дистрибутивом).\n\nЗдесь и далее буду приводить примеры под ОС Windows, так как именно она у меня сейчас под рукой. Запускаем IDLE (изначально запускается в интерактивном режиме), после чего уже можно начинать писать первую программу. Традиционно, первой программой у нас будет \"hello world\".\n\nЧтобы написать \"hello world\" на python, достаточно всего одной строки: \nprint(\"Hello world!\") Поздравляю! Вы написали свою первую программу на python!'),
(6, 'Начало работы. Visual Studio', 'C#', 'https://i.imgur.com/Kx1FwVN.jpg', 'Чтобы облегчить написание, а также тестирование и отладку программного кода нередко используют специальные среды разработки, в частности, Visual Studio. Рассмотрим создание приложений на C# с помощью бесплатной и полнофункциональной среды Visual Studio Community 2022, которую можно загрузить по следующему адресу: Microsoft Visual Studio 2022\nУстановка Visual Studio 2022\n\nПосле загрузки запустим программу установщика. В открывшемся окне нам будет предложено выбрать те компоненты, которые мы хотим установить вместе Visual Studio. Стоит отметить, что Visual Studio - очень функциональная среда разработки и позволяет разрабатывать приложения с помощью множества языков и платформ. В нашем случае нам будет интересовать прежде всего C# и .NET.\n\nЧтобы добавить в Visual Studio поддержку проектов для C# и .NET, в программе установки среди рабочих нагрузок можно выбрать только пункт ASP.NET и разработка веб-приложений. Можно выбрать и больше опций или вообще все опции, однако стоит учитывать свободный размер на жестком диске - чем больше опций будет выбрано, соответственно тем больше места на диске будет занято.\nУстановка Visual Studio 2022\n\nИ при инсталляции Visual Studio на ваш компьютер будут установлены все необходимые инструменты для разработки программ, в том числе фреймворк .NET.\n\nПосле завершения установки создадим первую программу. Она будет простенькой. Вначале откроем Visual Studio. На стартовом экране выберем Create a new project (Создать новый проект)\nСоздание первого проекта в Visual Studio 2022\n\nНа следующем окне в качестве типа проекта выберем Console App, то есть мы будем создавать консольное приложение на языке C#\nПроект консольного приложения на C# и .NET в Visual Studio 2022\n\nЧтобы проще было найти нужный тип проекта, в поле языков можно выбрать C#, а в поле типа проектов - Console.\n\nДалее на следующем этапе нам будет предложено указать имя проекта и каталог, где будет располагаться проект.\nСоздание первого приложения на C#\n\nВ поле Project Name дадим проекту какое-либо название. В моем случае это HelloApp.\n\nНа следующем окне Visual Studio предложит нам выбрать версию .NET, которая будет использоваться для проекта. Выберем последнюю на данный момент верси. - .NET 8.0:\nУстановка C# и .NET в Visual Studio\n\nНажмен на кнопку Create (Создать) для создания проекта, и после этого Visual Studio создаст и откроет нам проект:\nПервый проект на C#\n\nВ большом поле в центре, которое по сути представляет текстовый редактор, находится сгенерированный по умолчанию код C#. Впоследствии мы изменим его на свой.\n\nСправа находится окно Solution Explorer, в котором можно увидеть структуру нашего проекта. В данном случае у нас сгенерированная по умолчанию структура: узел Dependencies - это узел содержит сборки dll, которые добавлены в проект по умолчанию. Эти сборки как раз содержат классы библиотеки .NET, которые будет использовать C#. Однако не всегда все сборки нужны. Ненужные потом можно удалить, в то же время если понадобится добавить какую-нибудь нужную библиотеку, то именно в этот узел она будет добавляться.\n\nДалее идет непосредственно сам файл кода программы Program.cs, который по умолчанию открыт в центральном окне и который имеет всего две строки:\n1\n2\n	\n// See https://aka.ms/new-console-template for more information\nConsole.WriteLine(\"Hello, World!\");\n\nПервая строка предваряется символами // и представляет комментарии - пояснения к коду.\n\nВторая строка собственно представляет собой код программы: Console.WriteLine(\"Hello World!\");. Эта строка выводит на консоль строку \"Hello World!\".\n\nНесмотря на то, что программа содержит только одну строку кода, это уже некоторая программа, которую мы можем запустить. Запустить проект мы можем с помощью клавиши F5 или с панели инструментов, нажав на зеленую стрелку. И если вы все сделали правильно, то при запуске приложения на консоль будет выведена строка \"Hello World!\".\nПервое приложение на C# и .NET\n\nТеперь изменим весь этот код на следующий:\n1\n2\n3\n	\nConsole.Write(\"Введите свое имя: \");\nvar name = Console.ReadLine();       // вводим имя\nConsole.WriteLine($\"Привет {name}\");    // выводим имя на консоль\n\nПо сравнению с автоматически сгенерированным кодом я внес несколько изменений. Теперь первой строкой выводится приглашение к вводу.\n1\n	\nConsole.Write(\"Введите свое имя: \");\n\nМетод Console.Write() выводит на консоль некоторую строку. В данном случае это строка \"Введите свое имя: \".\n\nНа второй строке определяется строковая переменная name, в которую пользователь вводит информацию с консоли:\n1\n	\nvar name = Console.ReadLine();\n\nКлючевое слово var указывает на определение переменной. В данном случае переменная называется name. И ей присваивается результат метода Console.ReadLine(), который позволяет считать с консоли введенную строку. То есть мы введем в консоли строку (точнее имя), и эта строка окажется в переменой name.\n\nЗатем введенное имя выводится на консоль:\n1\n	\nConsole.WriteLine($\"Привет {name}\");\n\nЧтобы ввести значение переменной name внутрь выводимой на консоль строки, применяются фигурные скобки {}. То есть при выводе строки на консоль выражение {name} будет заменяться на значение переменной name - введенное имя.\n\nОднако чтобы можно было вводить таким образом значения переменных внутрь строки, перед строкой указывается знак доллара $.\n\nТеперь протестируем проект, запустив его на выполнение, также нажав на F5 или зеленую стрелочку.\nПервая программа на C#\n\nСкомпилированное приложение можно найти в папке проекта в каталоге bin\\Debug\\net8.0. Оно будет называться по имени проекта и иметь расширение exe. И затем этот файл можно будет запускать без Visual Studio, а также переносить его на другие компьютеры, где установлен .NET 8.'),
(7, 'Синтаксис языка Python', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Foffice-guru.ru%2Fwp-content%2Fuploads%2F2021%2F06%2Fpython-easy-way-to-do-geometric-mean-in-python.jpg&f=1&nofb=1&ipt=6a090b82fb9cea3373f4dd42b84498201d6f2fa5fb83f244b82726f2895df05d&ipo=images', '    Конец строки является концом инструкции (точка с запятой не требуется).\r\n\r\n    Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. И про читаемость кода не забывайте. Отступ в 1 пробел, к примеру, не лучшее решение. Используйте 4 пробела (или знак табуляции, на худой конец).\r\n\r\n    Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.\r\n\r\n    Основная инструкция:\r\n        Вложенный блок инструкций\r\n\r\nНесколько специальных случаев\r\n\r\n    Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:\r\n\r\n    a = 1; b = 2; print(a, b)\r\n\r\n    Но не делайте это слишком часто! Помните об удобочитаемости. А лучше вообще так не делайте.\r\n\r\n    Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:\r\n\r\n    if (a == 1 and b == 2 and\r\n        c == 3 and d == 4):  # Не забываем про двоеточие\r\n          print(\"spam\" * 3)\r\n\r\n    Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций. Ну я думаю, вы поняли :). Давайте лучше пример приведу:\r\n\r\n    if x > y: print(x)'),
(8, 'Программа не работает. Что делать?', 'Python', 'https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.automationminds.com%2Fwp-content%2Fuploads%2F2019%2F03%2Fpython-error-handling-aws-lambda-600x456.png&f=1&nofb=1&ipt=6c2345e5372f1c870237caeb140314c5a1ae1d837716f3e86de1658f6660c07a&ipo=images', 'Моя программа не работает! Что делать? В данной статье я постараюсь собрать наиболее частые ошибки начинающих программировать на python 3, а также расскажу, как их исправлять.\r\n\r\nПроблема: Моя программа не запускается. На доли секунды появляется чёрное окошко, а затем исчезает.\r\n\r\nПричина: после окончания выполнения программы (после выполнения всего кода или при возникновении исключения программа закрывается. И если вы её вызвали двойным кликом по иконке (а вы, скорее всего, вызвали её именно так), то она закроется вместе с окошком, в котором находится вывод программы.\r\n\r\nРешение: запускать программу через IDLE или через консоль.\r\n\r\nПроблема: Не работает функция input. Пишет SyntaxError.\r\n\r\nПример кода:\r\n>>>\r\n\r\n>>> a = input()\r\nhello world\r\n  File \"<string>\", line 1\r\n    hello world\r\n              ^\r\nSyntaxError: unexpected EOF while parsing\r\n\r\nПричина: Вы запустили Python 2.\r\n\r\nРешение: Установить Python 3.\r\n\r\nПроблема: Где-то увидел простую программу, а она не работает.\r\n\r\nПример кода:\r\n\r\nname = raw_input()\r\nprint name\r\n\r\nОшибка:\r\n\r\n  File \"a.py\", line 3\r\n    print name\r\n             ^\r\nSyntaxError: invalid syntax\r\n\r\nПричина: Вам подсунули программу на Python 2.\r\n\r\nРешение: Прочитать об отличиях Python 2 от Python 3. Переписать её на Python 3. Например, данная программа на Python 3 будет выглядеть так:\r\n\r\nname = input()\r\nprint(name)\r\n\r\nПроблема: TypeError: Can\"t convert \"int\" object to str implicitly.\r\n\r\nПример кода:\r\n\r\n>>> a = input() + 5\r\n8\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: Can\"t convert \"int\" object to str implicitly\r\n\r\nПричина: Нельзя складывать строку с числом.\r\n\r\nРешение: Привести строку к числу с помощью функции int(). Кстати, заметьте, что функция input() всегда возвращает строку!\r\n>>>\r\n\r\n>>> a = int(input()) + 5\r\n8\r\n>>> a\r\n13\r\n\r\nПроблема: SyntaxError: invalid syntax.\r\n\r\nПример кода:\r\n\r\na = 5\r\nif a == 5\r\n    print(\"Ура!\")\r\n\r\nОшибка:\r\n\r\n  File \"a.py\", line 3\r\n    if a == 5\r\n            ^\r\nSyntaxError: invalid syntax\r\n\r\nПричина: Забыто двоеточие.\r\n\r\nРешение:\r\n\r\na = 5\r\nif a == 5:\r\n    print(\"Ура!\")\r\n\r\nПроблема: SyntaxError: invalid syntax.\r\n\r\nПример кода:\r\n\r\na = 5\r\nif a = 5:\r\n    print(\"Ура!\")\r\n\r\nОшибка:\r\n\r\n  File \"a.py\", line 3\r\n    if a = 5\r\n         ^\r\nSyntaxError: invalid syntax\r\n\r\nПричина: Забыто равно.\r\n\r\nРешение:\r\n\r\na = 5\r\nif a == 5:\r\n    print(\"Ура!\")\r\n\r\nПроблема: NameError: name \"a\" is not defined.\r\n\r\nПример кода:\r\n\r\nprint(a)\r\n\r\nПричина: Переменная \"a\" не существует. Возможно, вы опечатались в названии или забыли инициализировать её.\r\n\r\nРешение: Исправить опечатку.\r\n\r\na = 10\r\nprint(a)\r\n\r\nПроблема: IndentationError: expected an indented block.\r\n\r\nПример кода:\r\n\r\na = 10\r\nif a > 0:\r\nprint(a)\r\n\r\nПричина: Нужен отступ.\r\n\r\nРешение:\r\n\r\na = 10\r\nif a > 0:\r\n    print(a)\r\n\r\nПроблема: TabError: inconsistent use of tabs and spaces in indentation.\r\n\r\nПример кода:\r\n\r\na = 10\r\nif a > 0:\r\n    print(a)\r\n    print(\"Ура!\")\r\n\r\nОшибка:\r\n\r\n  File \"a.py\", line 5\r\n    print(\"Ура!\")\r\n                 ^\r\nTabError: inconsistent use of tabs and spaces in indentation\r\n\r\nПричина: Смешение пробелов и табуляции в отступах.\r\n\r\nРешение: Исправить отступы.\r\n\r\na = 10\r\nif a > 0:\r\n    print(a)\r\n    print(\"Ура!\")\r\n\r\nПроблема: UnboundLocalError: local variable \"a\" referenced before assignment.\r\n\r\nПример кода:\r\n\r\ndef f():\r\n    a += 1\r\n    print(a)\r\n\r\na = 10\r\nf()\r\n\r\nОшибка:\r\n\r\nTraceback (most recent call last):\r\n  File \"a.py\", line 7, in <module>\r\n    f()\r\n  File \"a.py\", line 3, in f\r\n    a += 1\r\nUnboundLocalError: local variable \"a\" referenced before assignment\r\n\r\nПричина: Попытка обратиться к локальной переменной, которая ещё не создана.\r\n\r\nРешение:\r\n\r\ndef f():\r\n    global a\r\n    a += 1\r\n    print(a)\r\n\r\na = 10\r\nf()\r\n\r\nПроблема: Программа выполнилась, но в файл ничего не записалось / записалось не всё.\r\n\r\nПример кода:\r\n>>>\r\n\r\n>>> f = open(\"output.txt\", \"w\", encoding=\"utf-8\")\r\n>>> f.write(\"bla\")\r\n3\r\n>>>\r\n\r\nПричина: Не закрыт файл, часть данных могла остаться в буфере.\r\n\r\nРешение:\r\n>>>\r\n\r\n>>> f = open(\"output.txt\", \"w\", encoding=\"utf-8\")\r\n>>> f.write(\"bla\")\r\n3\r\n>>> f.close()\r\n>>>'),
(9, 'Инструкция if-elif-else', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fdaily-dev-tips.com%2Fimages%2F22-05-2021.jpg&f=1&nofb=1&ipt=eca24aac8bb9d90c797c1f3673007d2ea56397ebca347129cd55f071a784d619&ipo=images', 'Условная инструкция if-elif-else (её ещё иногда называют оператором ветвления) - основной инструмент выбора в Python. Проще говоря, она выбирает, какое действие следует выполнить, в зависимости от значения переменных в момент проверки условия.\r\nСинтаксис инструкции if\r\n\r\nСначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:\r\n\r\nif test1:\r\n    state1\r\nelif test2:\r\n    state2\r\nelse:\r\n    state3\r\n\r\nПростой пример (напечатает \"true\", так как 1 - истина):\r\n\r\n>>> if 1:\r\n...     print(\"true\")\r\n... else:\r\n...     print(\"false\")\r\n...\r\ntrue\r\n\r\nЧуть более сложный пример (его результат будет зависеть от того, что ввёл пользователь):\r\n\r\na = int(input())\r\nif a < -5:\r\n    print(\"Low\")\r\nelif -5 <= a <= 5:\r\n    print(\"Mid\")\r\nelse:\r\n    print(\"High\")\r\n\r\nКонструкция с несколькими elif может также служить отличной заменой конструкции switch - case в других языках программирования.\r\nПроверка истинности в Python\r\n\r\n    Любое число, не равное 0, или непустой объект - истина.\r\n    Числа, равные 0, пустые объекты и значение None - ложь\r\n    Операции сравнения применяются к структурам данных рекурсивно\r\n    Операции сравнения возвращают True или False\r\n    Логические операторы and и or возвращают истинный или ложный объект-операнд\r\n\r\nЛогические операторы:\r\n\r\nX and Y\r\n\r\nИстина, если оба значения X и Y истинны.\r\n\r\nX or Y\r\n\r\nИстина, если хотя бы одно из значений X или Y истинно.\r\n\r\nnot X\r\n\r\nИстина, если X ложно.\r\nТрехместное выражение if/else\r\n\r\nСледующая инструкция:\r\n\r\nif X:\r\n    A = Y\r\nelse:\r\n    A = Z\r\n\r\nдовольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение if/else:\r\n\r\nA = Y if X else Z\r\n\r\nВ данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.\r\n>>>\r\n\r\n>>> A = \"t\" if \"spam\" else \"f\"\r\n>>> A\r\n\"t\"'),
(10, 'Циклы for и while, break и continue, else', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.pythonpool.com%2Fwp-content%2Fuploads%2F2021%2F07%2FWhile-Loop-Vs.-For-Loop.jpg&f=1&nofb=1&ipt=1a466653d0d8d1790569fede404c064a024a4334d0d580a4ecbd38ed25a5760b&ipo=images', 'В этой статье я расскажу о циклах for и while, операторах break и continue, а также о слове else, которое, будучи употребленное с циклом, может сделать программный код несколько более понятным.\r\nЦикл while\r\n\r\nWhile - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.\r\n>>>\r\n\r\n>>> i = 5\r\n>>> while i < 15:\r\n...     print(i)\r\n...     i = i + 2\r\n...\r\n5\r\n7\r\n9\r\n11\r\n13\r\n\r\nЦикл for\r\n\r\nЦикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (например строке или списку), и во время каждого прохода выполняет тело цикла.\r\n>>>\r\n\r\n>>> for i in \"hello world\":\r\n...     print(i * 2, end=\"\")\r\n...\r\nhheelllloo  wwoorrlldd\r\n\r\nОператор continue\r\n\r\nОператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)\r\n>>>\r\n\r\n>>> for i in \"hello world\":\r\n...     if i == \"o\":\r\n...         continue\r\n...     print(i * 2, end=\"\")\r\n...\r\nhheellll  wwrrlldd\r\n\r\nОператор break\r\n\r\nОператор break досрочно прерывает цикл.\r\n>>>\r\n\r\n>>> for i in \"hello world\":\r\n...     if i == \"o\":\r\n...         break\r\n...     print(i * 2, end=\"\")\r\n...\r\nhheellll\r\n\r\nВолшебное слово else\r\n\r\nСлово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же \"естественным\" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.\r\n>>>\r\n\r\n>>> for i in \"hello world\":\r\n...     if i == \"a\":\r\n...         break\r\n... else:\r\n...     print(\"Буквы a в строке нет\")\r\n...\r\nБуквы a в строке нет'),
(11, 'Ключевые слова, модуль keyword', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fcdn.analyticsvidhya.com%2Fwp-content%2Fuploads%2F2021%2F07%2F38787wallpaper.png&f=1&nofb=1&ipt=0b6a107b9f86f73b2693c9bf9d03d53ef4d8286512591131ef835314714088bb&ipo=images', 'Сегодня я по-быстрому пробегусь по всем ключевым словам в Python, а заодно и по модулю keyword.\r\nКлючевые слова\r\n\r\nFalse - ложь.\r\n\r\nTrue - правда.\r\n\r\nNone - \"пустой\" объект.\r\n\r\nand - логическое И.\r\n\r\nwith / as - менеджер контекста.\r\n\r\nassert условие - возбуждает исключение, если условие ложно.\r\n\r\nbreak - выход из цикла.\r\n\r\nclass - пользовательский тип, состоящий из методов и атрибутов.\r\n\r\ncontinue - переход на следующую итерацию цикла.\r\n\r\ndef - определение функции.\r\n\r\ndel - удаление объекта.\r\n\r\nelif - в противном случае, если.\r\n\r\nelse - см. for/else или if/else.\r\n\r\nexcept - перехватить исключение.\r\n\r\nfinally - вкупе с инструкцией try, выполняет инструкции независимо от того, было ли исключение или нет.\r\n\r\nfor - цикл for.\r\n\r\nfrom - импорт нескольких функций из модуля.\r\n\r\nglobal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции.\r\n\r\nif - если.\r\n\r\nimport - импорт модуля.\r\n\r\nin - проверка на вхождение.\r\n\r\nis - ссылаются ли 2 объекта на одно и то же место в памяти.\r\n\r\nlambda - определение анонимной функции.\r\n\r\nnonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции.\r\n\r\nnot - логическое НЕ.\r\n\r\nor - логическое ИЛИ.\r\n\r\npass - ничего не делающая конструкция.\r\n\r\nraise - возбудить исключение.\r\n\r\nreturn - вернуть результат.\r\n\r\ntry - выполнить инструкции, перехватывая исключения.\r\n\r\nwhile - цикл while.\r\n\r\nyield - определение функции-генератора.\r\nМодуль keyword\r\n\r\nВ общем-то, keyword - не такой уж и модуль, но все же.\r\n\r\nkeyword.kwlist - список всех доступных ключевых слов.\r\n\r\nkeyword.iskeyword(строка) - является ли строка ключевым словом.'),
(12, 'Встроенные функции', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2F365datascience.com%2Fresources%2Fblog%2F2017-11-Python-Functions-min.png&f=1&nofb=1&ipt=a1beadcae9f36a99d8d38f3a2c733f69474b2a1fc96126608c47f49a235b427e&ipo=images', 'Краткий обзор встроенных функций в Python 3.\r\nВстроенные функции, выполняющие преобразование типов\r\n\r\nbool(x) - преобразование к типу bool, использующая стандартную процедуру проверки истинности. Если х является ложным или опущен, возвращает значение False, в противном случае она возвращает True.\r\n\r\nbytearray([источник [, кодировка [ошибки]]]) - преобразование к bytearray. Bytearray - изменяемая последовательность целых чисел в диапазоне 0≤X<256. Вызванная без аргументов, возвращает пустой массив байт.\r\n\r\nbytes([источник [, кодировка [ошибки]]]) - возвращает объект типа bytes, который является неизменяемой последовательностью целых чисел в диапазоне 0≤X<256. Аргументы конструктора интерпретируются как для bytearray().\r\n\r\ncomplex([real[, imag]]) - преобразование к комплексному числу.\r\n\r\ndict([object]) - преобразование к словарю.\r\n\r\nfloat([X]) - преобразование к числу с плавающей точкой. Если аргумент не указан, возвращается 0.0.\r\n\r\nfrozenset([последовательность]) - возвращает неизменяемое множество.\r\n\r\nint([object], [основание системы счисления]) - преобразование к целому числу.\r\n\r\nlist([object]) - создает список.\r\n\r\nmemoryview([object]) - создает объект memoryview.\r\n\r\nobject() - возвращает безликий объект, являющийся базовым для всех объектов.\r\n\r\nrange([start=0], stop, [step=1]) - арифметическая прогрессия от start до stop с шагом step.\r\n\r\nset([object]) - создает множество.\r\n\r\nslice([start=0], stop, [step=1]) - объект среза от start до stop с шагом step.\r\n\r\nstr([object], [кодировка], [ошибки]) - строковое представление объекта. Использует метод __str__.\r\n\r\ntuple(obj) - преобразование к кортежу.\r\nДругие встроенные функции\r\n\r\nabs(x) - Возвращает абсолютную величину (модуль числа).\r\n\r\nall(последовательность) - Возвращает True, если все элементы истинные (или, если последовательность пуста).\r\n\r\nany(последовательность) - Возвращает True, если хотя бы один элемент - истина. Для пустой последовательности возвращает False.\r\n\r\nascii(object) - Как repr(), возвращает строку, содержащую представление объекта, но заменяет не-ASCII символы на экранированные последовательности.\r\n\r\nbin(x) - Преобразование целого числа в двоичную строку.\r\n\r\ncallable(x) - Возвращает True для объекта, поддерживающего вызов (как функции).\r\n\r\nchr(x) - Возвращает односимвольную строку, код символа которой равен x.\r\n\r\nclassmethod(x) - Представляет указанную функцию методом класса.\r\n\r\ncompile(source, filename, mode, flags=0, dont_inherit=False) - Компиляция в программный код, который впоследствии может выполниться функцией eval или exec. Строка не должна содержать символов возврата каретки или нулевые байты.\r\n\r\ndelattr(object, name) - Удаляет атрибут с именем \"name\".\r\n\r\ndir([object]) - Список имен объекта, а если объект не указан, список имен в текущей локальной области видимости.\r\n\r\ndivmod(a, b) - Возвращает частное и остаток от деления a на b.\r\n\r\nenumerate(iterable, start=0) - Возвращает итератор, при каждом проходе предоставляющем кортеж из номера и соответствующего члена последовательности.\r\n\r\neval(expression, globals=None, locals=None) - Выполняет строку программного кода.\r\n\r\nexec(object[, globals[, locals]]) - Выполняет программный код на Python.\r\n\r\nfilter(function, iterable) - Возвращает итератор из тех элементов, для которых function возвращает истину.\r\n\r\nformat(value[,format_spec]) - Форматирование (обычно форматирование строки).\r\n\r\ngetattr(object, name ,[default]) - извлекает атрибут объекта или default.\r\n\r\nglobals() - Словарь глобальных имен.\r\n\r\nhasattr(object, name) - Имеет ли объект атрибут с именем \"name\".\r\n\r\nhash(x) - Возвращает хеш указанного объекта.\r\n\r\nhelp([object]) - Вызов встроенной справочной системы.\r\n\r\nhex(х) - Преобразование целого числа в шестнадцатеричную строку.\r\n\r\nid(object) - Возвращает \"адрес\" объекта. Это целое число, которое гарантированно будет уникальным и постоянным для данного объекта в течение срока его существования.\r\n\r\ninput([prompt]) - Возвращает введенную пользователем строку. Prompt - подсказка пользователю.\r\n\r\nisinstance(object, ClassInfo) - Истина, если объект является экземпляром ClassInfo или его подклассом. Если объект не является объектом данного типа, функция всегда возвращает ложь.\r\n\r\nissubclass(класс, ClassInfo) - Истина, если класс является подклассом ClassInfo. Класс считается подклассом себя.\r\n\r\niter(x) - Возвращает объект итератора.\r\n\r\nlen(x) - Возвращает число элементов в указанном объекте.\r\n\r\nlocals() - Словарь локальных имен.\r\n\r\nmap(function, iterator) - Итератор, получившийся после применения к каждому элементу последовательности функции function.\r\n\r\nmax(iter, [args ...] * [, key]) - Максимальный элемент последовательности.\r\n\r\nmin(iter, [args ...] * [, key]) - Минимальный элемент последовательности.\r\n\r\nnext(x) - Возвращает следующий элемент итератора.\r\n\r\noct(х) - Преобразование целого числа в восьмеричную строку.\r\n\r\nopen(file, mode=\"r\", buffering=None, encoding=None, errors=None, newline=None, closefd=True) - Открывает файл и возвращает соответствующий поток.\r\n\r\nord(с) - Код символа.\r\n\r\npow(x, y[, r]) - ( x ** y ) % r.\r\n\r\nreversed(object) - Итератор из развернутого объекта.\r\n\r\nrepr(obj) - Представление объекта.\r\n\r\nprint([object, ...], *, sep=\" \", end=\"\n\", file=sys.stdout) - Печать.\r\n\r\nproperty(fget=None, fset=None, fdel=None, doc=None)\r\n\r\nround(X [, N]) - Округление до N знаков после запятой.\r\n\r\nsetattr(объект, имя, значение) - Устанавливает атрибут объекта.\r\n\r\nsorted(iterable[, key][, reverse]) - Отсортированный список.\r\n\r\nstaticmethod(function) - Статический метод для функции.\r\n\r\nsum(iter, start=0) - Сумма членов последовательности.\r\n\r\nsuper([тип [, объект или тип]]) - Доступ к родительскому классу.\r\n\r\ntype(object) - Возвращает тип объекта.\r\n\r\ntype(name, bases, dict) - Возвращает новый экземпляр класса name.\r\n\r\nvars([object]) - Словарь из атрибутов объекта. По умолчанию - словарь локальных имен.\r\n\r\nzip(*iters) - Итератор, возвращающий кортежи, состоящие из соответствующих элементов аргументов-последовательностей.');
INSERT INTO `article` (`id`, `title`, `genre`, `image`, `description`) VALUES
(13, 'Числа: целые, вещественные, комплексные', 'Python', 'https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Finphormatika.ru%2Fimg%2Fim_389.png&f=1&nofb=1&ipt=fabf624c0b95c0bef7ec87bf9c14548c92adf1fc431a0e2f17d45ce49209732e&ipo=images', 'Числа в Python 3: целые, вещественные, комплексные. Работа с числами и операции над ними.\r\nЦелые числа (int)\r\n\r\nЧисла в Python 3 ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:\r\nx + y	Сложение\r\nx - y	Вычитание\r\nx * y	Умножение\r\nx / y	Деление\r\nx // y	Получение целой части от деления\r\nx % y	Остаток от деления\r\n-x	Смена знака числа\r\nabs(x)	Модуль числа\r\ndivmod(x, y)	Пара (x // y, x % y)\r\nx ** y	Возведение в степень\r\npow(x, y[, z])	xy по модулю (если модуль задан)\r\n\r\nТакже нужно отметить, что целые числа в python 3, в отличие от многих других языков, поддерживают длинную арифметику (однако, это требует больше памяти).\r\n>>>\r\n\r\n>>> 255 + 34\r\n289\r\n>>> 5 * 2\r\n10\r\n>>> 20 / 3\r\n6.666666666666667\r\n>>> 20 // 3\r\n6\r\n>>> 20 % 3\r\n2\r\n>>> 3 ** 4\r\n81\r\n>>> pow(3, 4)\r\n81\r\n>>> pow(3, 4, 27)\r\n0\r\n>>> 3 ** 150\r\n369988485035126972924700782451696644186473100389722973815184405301748249\r\n\r\nБитовые операции\r\n\r\nНад целыми числами также можно производить битовые операции\r\nx | y	Побитовое или\r\nx ^ y	Побитовое исключающее или\r\nx & y	Побитовое и\r\nx << n	Битовый сдвиг влево\r\nx >> y	Битовый сдвиг вправо\r\n~x	Инверсия битов\r\nДополнительные методы\r\n\r\nint.bit_length() - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и лидирующих нулей.\r\n>>>\r\n\r\n>>> n = -37\r\n>>> bin(n)\r\n\"-0b100101\"\r\n>>> n.bit_length()\r\n6\r\n\r\nint.to_bytes(length, byteorder, *, signed=False) - возвращает строку байтов, представляющих это число.\r\n>>>\r\n\r\n>>> (1024).to_bytes(2, byteorder=\"big\")\r\nb\"x04x00\"\r\n>>> (1024).to_bytes(10, byteorder=\"big\")\r\nb\"x00x00x00x00x00x00x00x00x04x00\"\r\n>>> (-1024).to_bytes(10, byteorder=\"big\", signed=True)\r\nb\"xffxffxffxffxffxffxffxffxfcx00\"\r\n>>> x = 1000\r\n>>> x.to_bytes((x.bit_length() // 8) + 1, byteorder=\"little\")\r\nb\"xe8x03\"\r\n\r\nclassmethod int.from_bytes(bytes, byteorder, *, signed=False) - возвращает число из данной строки байтов.\r\n>>>\r\n\r\n>>> int.from_bytes(b\"x00x10\", byteorder=\"big\")\r\n16\r\n>>> int.from_bytes(b\"x00x10\", byteorder=\"little\")\r\n4096\r\n>>> int.from_bytes(b\"xfcx00\", byteorder=\"big\", signed=True)\r\n-1024\r\n>>> int.from_bytes(b\"xfcx00\", byteorder=\"big\", signed=False)\r\n64512\r\n>>> int.from_bytes([255, 0, 0], byteorder=\"big\")\r\n16711680\r\n\r\nСистемы счисления\r\n\r\nТе, у кого в школе была информатика, знают, что числа могут быть представлены не только в десятичной системе счисления. К примеру, в компьютере используется двоичный код, и, к примеру, число 19 в двоичной системе счисления будет выглядеть как 10011. Также иногда нужно переводить числа из одной системы счисления в другую. Python для этого предоставляет несколько функций:\r\n\r\n    int([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.\r\n    bin(x) - преобразование целого числа в двоичную строку.\r\n    hex(х) - преобразование целого числа в шестнадцатеричную строку.\r\n    oct(х) - преобразование целого числа в восьмеричную строку.\r\n\r\nПримеры:\r\n>>>\r\n\r\n>>> a = int(\"19\") # Переводим строку в число\r\n>>> b = int(\"19.5\")  # Строка не является целым числом\r\nTraceback (most recent call last):\r\n  File \"\", line 1, in\r\nValueError: invalid literal for int() with base 10: \"19.5\"\r\n>>> c = int(19.5)  # Применённая к числу с плавающей точкой, отсекает дробную часть\r\n>>> print(a, c)\r\n19 19\r\n>>> bin(19)\r\n\"0b10011\"\r\n>>> oct(19)\r\n\"0o23\"\r\n>>> hex(19)\r\n\"0x13\"\r\n>>> 0b10011  # Так тоже можно записывать числовые константы\r\n19\r\n>>> int(\"10011\", 2)\r\n19\r\n>>> int(\"0b10011\", 2)\r\n19\r\n\r\nВещественные числа (float)\r\n\r\nВещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:\r\n>>>\r\n\r\n>>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1\r\n0.9999999999999999\r\n\r\nДля высокой точности используют другие объекты (например Decimal и Fraction)).\r\n\r\nТакже вещественные числа не поддерживают длинную арифметику:\r\n>>>\r\n\r\n>>> a = 3 ** 1000\r\n>>> a + 0.1\r\nTraceback (most recent call last):\r\n  File \"\", line 1, in\r\nOverflowError: int too large to convert to float\r\n\r\nПростенькие примеры работы с числами:\r\n>>>\r\n\r\n>>> c = 150\r\n>>> d = 12.9\r\n>>> c + d\r\n162.9\r\n>>> p = abs(d - c)  # Модуль числа\r\n>>> print(p)\r\n137.1\r\n>>> round(p)  # Округление\r\n137\r\n\r\nДополнительные методы\r\n\r\nfloat.as_integer_ratio() - пара целых чисел, чьё отношение равно этому числу.\r\n\r\nfloat.is_integer() - является ли значение целым числом.\r\n\r\nfloat.hex() - переводит float в hex (шестнадцатеричную систему счисления).\r\n\r\nclassmethod float.fromhex(s) - float из шестнадцатеричной строки.\r\n>>>\r\n\r\n>>> (10.5).hex()\r\n\"0x1.5000000000000p+3\"\r\n>>> float.fromhex(\"0x1.5000000000000p+3\")\r\n10.5\r\n\r\nПомимо стандартных выражений для работы с числами (а в Python их не так уж и много), в составе Python есть несколько полезных модулей.\r\n\r\nМодуль math предоставляет более сложные математические функции.\r\n>>>\r\n\r\n>>> import math\r\n>>> math.pi\r\n3.141592653589793\r\n>>> math.sqrt(85)\r\n9.219544457292887\r\n\r\nМодуль random реализует генератор случайных чисел и функции случайного выбора.\r\n>>>\r\n\r\n>>> import random\r\n>>> random.random()\r\n0.15651968855132303\r\n\r\nКомплексные числа (complex)\r\n\r\nВ Python встроены также и комплексные числа:\r\n>>>\r\n\r\n>>> x = complex(1, 2)\r\n>>> print(x)\r\n(1+2j)\r\n>>> y = complex(3, 4)\r\n>>> print(y)\r\n(3+4j)\r\n>>> z = x + y\r\n>>> print(x)\r\n(1+2j)\r\n>>> print(z)\r\n(4+6j)\r\n>>> z = x * y\r\n>>> print(z)\r\n(-5+10j)\r\n>>> z = x / y\r\n>>> print(z)\r\n(0.44+0.08j)\r\n>>> print(x.conjugate())  # Сопряжённое число\r\n(1-2j)\r\n>>> print(x.imag)  # Мнимая часть\r\n2.0\r\n>>> print(x.real)  # Действительная часть\r\n1.0\r\n>>> print(x > y)  # Комплексные числа нельзя сравнить\r\nTraceback (most recent call last):\r\n  File \"\", line 1, in\r\nTypeError: unorderable types: complex() > complex()\r\n>>> print(x == y)  # Но можно проверить на равенство\r\nFalse\r\n>>> abs(3 + 4j)  # Модуль комплексного числа\r\n5.0\r\n>>> pow(3 + 4j, 2)  # Возведение в степень\r\n(-7+24j)\r\n\r\nДля работы с комплексными числами используется также модуль cmath.'),
(14, 'Списки (list). Функции и методы списков', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fprogramfiles.info%2Fwp-content%2Fuploads%2F2019%2F12%2Fpython-list-678x509.png&f=1&nofb=1&ipt=2145bd56e60d5bb7676c20ec734cb83d2b4c5e314ace12b397851ed1b333f356&ipo=images', 'Сегодня я расскажу о таком типе данных, как списки, операциях над ними и методах, о генераторах списков и о применении списков.\r\nЧто такое списки?\r\n\r\nСписки в Python - упорядоченные изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).\r\n\r\nЧтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией list:\r\n>>>\r\n\r\n>>> list(\"список\")\r\n[\"с\", \"п\", \"и\", \"с\", \"о\", \"к\"]\r\n\r\nСписок можно создать и при помощи литерала:\r\n>>>\r\n\r\n>>> s = []  # Пустой список\r\n>>> l = [\"s\", \"p\", [\"isok\"], 2]\r\n>>> s\r\n[]\r\n>>> l\r\n[\"s\", \"p\", [\"isok\"], 2]\r\n\r\nКак видно из примера, список может содержать любое количество любых объектов (в том числе и вложенные списки), или не содержать ничего.\r\n\r\nИ еще один способ создать список - это генераторы списков. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл for.\r\n>>>\r\n\r\n>>> c = [c * 3 for c in \"list\"]\r\n>>> c\r\n[\"lll\", \"iii\", \"sss\", \"ttt\"]\r\n\r\nВозможна и более сложная конструкция генератора списков:\r\n>>>\r\n\r\n>>> c = [c * 3 for c in \"list\" if c != \"i\"]\r\n>>> c\r\n[\"lll\", \"sss\", \"ttt\"]\r\n>>> c = [c + d for c in \"list\" if c != \"i\" for d in \"spam\" if d != \"a\"]\r\n>>> c\r\n[\"ls\", \"lp\", \"lm\", \"ss\", \"sp\", \"sm\", \"ts\", \"tp\", \"tm\"]\r\n\r\nНо в сложных случаях лучше пользоваться обычным циклом for для генерации списков.\r\nФункции и методы списков\r\n\r\nСоздать создали, теперь нужно со списком что-то делать. Для списков доступны основные встроенные функции, а также методы списков.\r\nТаблица \"методы списков\"\r\nМетод	Что делает\r\nlist.append(x)	Добавляет элемент в конец списка\r\nlist.extend(L)	Расширяет список list, добавляя в конец все элементы списка L\r\nlist.insert(i, x)	Вставляет на i-ый элемент значение x\r\nlist.remove(x)	Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует\r\nlist.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент\r\nlist.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)\r\nlist.count(x)	Возвращает количество элементов со значением x\r\nlist.sort([key=функция])	Сортирует список на основе функции\r\nlist.reverse()	Разворачивает список\r\nlist.copy()	Поверхностная копия списка\r\nlist.clear()	Очищает список\r\n\r\nНужно отметить, что методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения не нужно записывать в эту переменную.\r\n>>>\r\n\r\n>>> l = [1, 2, 3, 5, 7]\r\n>>> l.sort()\r\n>>> l\r\n[1, 2, 3, 5, 7]\r\n>>> l = l.sort()\r\n>>> print(l)\r\nNone\r\n\r\nИ, напоследок, примеры работы со списками:\r\n>>>\r\n\r\n>>> a = [66.25, 333, 333, 1, 1234.5]\r\n>>> print(a.count(333), a.count(66.25), a.count(\"x\"))\r\n2 1 0\r\n>>> a.insert(2, -1)\r\n>>> a.append(333)\r\n>>> a\r\n[66.25, 333, -1, 333, 1, 1234.5, 333]\r\n>>> a.index(333)\r\n1\r\n>>> a.remove(333)\r\n>>> a\r\n[66.25, -1, 333, 1, 1234.5, 333]\r\n>>> a.reverse()\r\n>>> a\r\n[333, 1234.5, 1, 333, -1, 66.25]\r\n>>> a.sort()\r\n>>> a\r\n[-1, 1, 66.25, 333, 333, 1234.5]\r\n\r\nИзредка, для увеличения производительности, списки заменяют гораздо менее гибкими массивами (хотя в таких случаях обычно используют сторонние библиотеки, например NumPy).'),
(15, 'Словари (dict) и работа с ними. Методы словарей', 'Python', 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fsky.pro%2Fmedia%2Fwp-content%2Fuploads%2F2022%2F06%2Fglavnaya-49.png&f=1&nofb=1&ipt=3c57c249b7218ea8a20602637424dccd04a9a23742124879b08c2298effcf764&ipo=images', 'Сегодня я расскажу о таком типе данных, как словари, о работе со словарями, операциях над ними, методах, о генераторах словарей.\r\n\r\nСловари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.\r\n\r\nЧтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами. Во-первых, с помощью литерала:\r\n>>>\r\n\r\n>>> d = {}\r\n>>> d\r\n{}\r\n>>> d = {\"dict\": 1, \"dictionary\": 2}\r\n>>> d\r\n{\"dict\": 1, \"dictionary\": 2}\r\n\r\nВо-вторых, с помощью функции dict:\r\n>>>\r\n\r\n>>> d = dict(short=\"dict\", long=\"dictionary\")\r\n>>> d\r\n{\"short\": \"dict\", \"long\": \"dictionary\"}\r\n>>> d = dict([(1, 1), (2, 4)])\r\n>>> d\r\n{1: 1, 2: 4}\r\n\r\nВ-третьих, с помощью метода fromkeys:\r\n>>>\r\n\r\n>>> d = dict.fromkeys([\"a\", \"b\"])\r\n>>> d\r\n{\"a\": None, \"b\": None}\r\n>>> d = dict.fromkeys([\"a\", \"b\"], 100)\r\n>>> d\r\n{\"a\": 100, \"b\": 100}\r\n\r\nВ-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.\r\n>>>\r\n\r\n>>> d = {a: a ** 2 for a in range(7)}\r\n>>> d\r\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}\r\n\r\nТеперь попробуем добавить записей в словарь и извлечь значения ключей:\r\n>>>\r\n\r\n>>> d = {1: 2, 2: 4, 3: 9}\r\n>>> d[1]\r\n2\r\n>>> d[4] = 4 ** 2\r\n>>> d\r\n{1: 2, 2: 4, 3: 9, 4: 16}\r\n>>> d[\"1\"]\r\nTraceback (most recent call last):\r\n  File \"\", line 1, in\r\n    d[\"1\"]\r\nKeyError: \"1\"\r\n\r\nКак видно из примера, присвоение по новому ключу расширяет словарь, присвоение по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение. Для избежания исключения есть специальный метод (см. ниже), или можно перехватывать исключение.\r\n\r\nЧто же можно еще делать со словарями? Да то же самое, что и с другими объектами: встроенные функции, ключевые слова (например, циклы for и while), а также специальные методы словарей.\r\nМетоды словарей\r\n\r\ndict.clear() - очищает словарь.\r\n\r\ndict.copy() - возвращает копию словаря.\r\n\r\nclassmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).\r\n\r\ndict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).\r\n\r\ndict.items() - возвращает пары (ключ, значение).\r\n\r\ndict.keys() - возвращает ключи в словаре.\r\n\r\ndict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).\r\n\r\ndict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.\r\n\r\ndict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).\r\n\r\ndict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).\r\n\r\ndict.values() - возвращает значения в словаре.'),
(16, 'Редакторы кода', 'JavaScript', 'https://i.imgur.com/cuKU19h.png', 'Большую часть своего рабочего времени программисты проводят в редакторах кода.\r\n\r\nЕсть два основных типа редакторов: IDE и «лёгкие» редакторы. Многие используют по одному инструменту каждого типа.\r\nIDE\r\n\r\nТермином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.\r\n\r\nIDE загружает проект (который может состоять из множества файлов), позволяет переключаться между файлами, предлагает автодополнение по коду всего проекта (а не только открытого файла), также она интегрирована с системой контроля версий (например, такой как git), средой для тестирования и другими инструментами на уровне всего проекта.\r\n\r\nЕсли вы ещё не выбрали себе IDE, присмотритесь к этим:\r\n\r\n    Visual Studio Code (кросс-платформенная, бесплатная).\r\n    WebStorm (кросс-платформенная, платная).\r\n\r\nДля Windows есть ещё Visual Studio (не путать с Visual Studio Code). Visual Studio – это платная мощная среда разработки, которая работает только на Windows. Она хорошо подходит для .NET платформы. У неё есть бесплатная версия, которая называется Visual Studio Community.\r\n\r\nМногие IDE платные, но у них есть пробный период. Их цена обычно незначительна по сравнению с зарплатой квалифицированного разработчика, так что пробуйте и выбирайте ту, что вам подходит лучше других.\r\n«Лёгкие» редакторы\r\n\r\n«Лёгкие» редакторы менее мощные, чем IDE, но они отличаются скоростью, удобным интерфейсом и простотой.\r\n\r\nВ основном их используют для того, чтобы быстро открыть и отредактировать нужный файл.\r\n\r\nГлавное отличие между «лёгким» редактором и IDE состоит в том, что IDE работает на уровне целого проекта, поэтому она загружает больше данных при запуске, анализирует структуру проекта, если это необходимо, и так далее. Если вы работаете только с одним файлом, то гораздо быстрее открыть его в «лёгком» редакторе.\r\n\r\nНа практике «лёгкие» редакторы могут иметь множество плагинов, включая автодополнение и анализаторы синтаксиса на уровне директории, поэтому границы между IDE и «лёгкими» редакторами размыты.\r\n\r\nСледующие варианты заслуживают вашего внимания:\r\n\r\n    Sublime Text (кроссплатформенный, условно-бесплатный).\r\n    Notepad++ (Windows, бесплатный).\r\n    Vim и Emacs тоже хороши, если знать, как ими пользоваться.\r\n\r\nНе будем ссориться\r\n\r\nРедакторы, перечисленные выше, известны автору давно и заслужили много хороших отзывов от коллег.\r\n\r\nКонечно же, есть много других отличных редакторов. Выбирайте тот, который вам больше нравится.\r\n\r\nВыбор редактора, как и любого другого инструмента, индивидуален и зависит от ваших проектов, привычек и личных предпочтений.\r\n'),
(18, 'Справочники и спецификации', 'JavaScript', 'https://i.imgur.com/9xtBVkg.png', 'Эта книга является учебником и нацелена на то, чтобы помочь вам постепенно освоить язык. Но когда вы хорошо изучите основы, вам понадобятся дополнительные источники информации.\r\nСпецификация\r\n\r\nСпецификация ECMA-262 содержит самую глубокую, детальную и формализованную информацию о JavaScript. Она определяет сам язык.\r\n\r\nВначале спецификация может показаться тяжеловатой для понимания из-за слишком формального стиля изложения. Если вы ищете источник самой достоверной информации, то это правильное место, но она не для ежедневного использования.\r\n\r\nНовая версия спецификации появляется каждый год. А пока она не вышла официально, все желающие могут ознакомиться с текущим черновиком на https://tc39.es/ecma262/.\r\n\r\nЧтобы почитать о самых последних возможностях, включая те, которые «почти в стандарте» (так называемые «stage 3 proposals»), посетите https://github.com/tc39/proposals.\r\n\r\nЕсли вы разрабатываете под браузеры, то существуют и другие спецификации, о которых рассказывается во второй части этого учебника.\r\nСправочники\r\n\r\n    MDN (Mozilla) JavaScript Reference – это справочник с примерами и другой информацией. Хороший источник для получения подробных сведений о функциях языка, методах встроенных объектов и так далее.\r\n\r\n    Располагается по адресу https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference.\r\n\r\n    Хотя зачастую вместо их сайта удобнее использовать какой-нибудь интернет-поисковик, вводя там запрос «MDN [что вы хотите найти]», например https://google.com/search?q=MDN+parseInt для поиска информации о функции parseInt.\r\n\r\nТаблицы совместимости\r\n\r\nJavaScript – это развивающийся язык, в который постоянно добавляется что-то новое.\r\n\r\nПосмотреть, какие возможности поддерживаются в разных браузерах и других движках, можно в следующих источниках:\r\n\r\n    http://caniuse.com – таблицы с информацией о поддержке по каждой возможности языка. Например, чтобы узнать, какие движки поддерживают современные криптографические функции, посетите: http://caniuse.com/#feat=cryptography.\r\n    https://kangax.github.io/compat-table – таблица с возможностями языка и движками, которые их поддерживают и не поддерживают.\r\n\r\nВсе эти ресурсы полезны в ежедневной работе программиста, так как они содержат ценную информацию о возможностях использования языка, их поддержке и так далее.\r\n\r\nПожалуйста, запомните эти ссылки (или ссылку на эту страницу) на случай, когда вам понадобится подробная информация о какой-нибудь конкретной возможности JavaScript.\r\n'),
(19, 'Консоль разработчика', 'JavaScript', 'https://blog.codepen.io/wp-content/uploads/2016/01/full-console.png', 'Код уязвим для ошибок. И вы, скорее всего, будете делать ошибки в коде… Впрочем, давайте будем откровенны: вы точно будете совершать ошибки в коде. В конце концов, вы человек, а не робот.\r\n\r\nНо по умолчанию в браузере ошибки не видны. То есть, если что-то пойдёт не так, мы не увидим, что именно сломалось, и не сможем это починить.\r\n\r\nДля решения задач такого рода в браузер встроены так называемые «Инструменты разработки» (Developer tools или сокращённо — devtools).\r\n\r\nChrome и Firefox снискали любовь подавляющего большинства программистов во многом благодаря своим отменным инструментам разработчика. Остальные браузеры, хотя и оснащены подобными инструментами, но всё же зачастую находятся в роли догоняющих и по качеству, и по количеству свойств и особенностей. В общем, почти у всех программистов есть свой «любимый» браузер. Другие используются только для отлова и исправления специфичных «браузерозависимых» ошибок.\r\n\r\nДля начала знакомства с этими мощными инструментами давайте выясним, как их открывать, смотреть ошибки и запускать команды JavaScript.\r\nGoogle Chrome\r\n\r\nОткройте страницу bug.html.\r\n\r\nВ её JavaScript-коде закралась ошибка. Она не видна обычному посетителю, поэтому давайте найдём её при помощи инструментов разработки.\r\n\r\nНажмите F12 или, если вы используете Mac, Cmd+Opt+J.\r\n\r\nПо умолчанию в инструментах разработчика откроется вкладка Console (консоль).\r\n\r\nОна выглядит приблизительно следующим образом:\r\n\r\nТочный внешний вид инструментов разработки зависит от используемой версии Chrome. Время от времени некоторые детали изменяются, но в целом внешний вид остаётся примерно похожим на предыдущие версии.\r\n\r\n    В консоли мы можем увидеть сообщение об ошибке, отрисованное красным цветом. В нашем случае скрипт содержит неизвестную команду «lalala».\r\n    Справа присутствует ссылка на исходный код bug.html:12 с номером строки кода, в которой эта ошибка и произошла.\r\n\r\nПод сообщением об ошибке находится синий символ >. Он обозначает командную строку, в ней мы можем редактировать и запускать JavaScript-команды. Для их запуска нажмите Enter.\r\nМногострочный ввод\r\n\r\nОбычно при нажатии Enter введённая строка кода сразу выполняется.\r\n\r\nЧтобы перенести строку, нажмите Shift+Enter. Так можно вводить более длинный JS-код.\r\n\r\nТеперь мы явно видим ошибки, для начала этого вполне достаточно. Мы ещё вернёмся к инструментам разработчика позже и более подробно рассмотрим отладку кода в главе Отладка в браузере.\r\nFirefox, Edge и другие\r\n\r\nИнструменты разработчика в большинстве браузеров открываются при нажатии на F12.\r\n\r\nИх внешний вид и принципы работы мало чем отличаются. Разобравшись с инструментами в одном браузере, вы без труда сможете работать с ними и в другом.\r\nSafari\r\n\r\nSafari (браузер для Mac, не поддерживается в системах Windows/Linux) всё же имеет небольшое отличие. Для начала работы нам нужно включить «Меню разработки» («Developer menu»).\r\n\r\nОткройте Настройки (Preferences) и перейдите к панели «Продвинутые» (Advanced). В самом низу вы найдёте чекбокс:\r\n\r\nТеперь консоль можно активировать нажатием клавиш Cmd+Opt+C. Также обратите внимание на новый элемент меню «Разработка» («Develop»). В нем содержится большое количество команд и настроек.\r\nИтого\r\n\r\n    Инструменты разработчика позволяют нам смотреть ошибки, выполнять команды, проверять значение переменных и ещё много всего полезного.\r\n    В большинстве браузеров, работающих под Windows, инструменты разработчика можно открыть, нажав F12. В Chrome для Mac используйте комбинацию Cmd+Opt+J, Safari: Cmd+Opt+C (необходимо предварительное включение «Меню разработчика»).\r\n\r\nТеперь наше окружение полностью настроено. В следующем разделе мы перейдём непосредственно к JavaScript.\r\n'),
(20, 'Привет, мир!', 'JavaScript', 'https://i.imgur.com/jRkAzCW.jpg', 'В этой части учебника мы изучаем собственно JavaScript, сам язык.\r\n\r\nНо нам нужна рабочая среда для запуска наших скриптов, и, поскольку это онлайн-книга, то браузер будет хорошим выбором. В этой главе мы сократим количество специфичных для браузера команд (например, alert) до минимума, чтобы вы не тратили на них время, если планируете сосредоточиться на другой среде (например, Node.js). А на использовании JavaScript в браузере мы сосредоточимся в следующей части учебника.\r\n\r\nИтак, сначала давайте посмотрим, как выполнить скрипт на странице. Для серверных сред (например, Node.js), вы можете выполнить скрипт с помощью команды типа \"node my.js\". Для браузера всё немного иначе.\r\nТег «script»\r\n\r\nПрограммы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>.\r\n\r\nДля примера:\r\n\r\n<!DOCTYPE HTML>\r\n<html>\r\n\r\n<body>\r\n\r\n  <p>Перед скриптом...</p>\r\n\r\n  <script>\r\n    alert( \"Привет, мир!\" );\r\n  </script>\r\n\r\n  <p>...После скрипта.</p>\r\n\r\n</body>\r\n\r\n</html>\r\n\r\nВы можете запустить пример, нажав на кнопку «Play» в правом верхнем углу блока с кодом выше.\r\n\r\nТег <script> содержит JavaScript-код, который автоматически выполнится, когда браузер его обработает.\r\nСовременная разметка\r\n\r\nТег <script> имеет несколько атрибутов, которые редко используются, но всё ещё могут встретиться в старом коде:\r\n\r\nАтрибут type: <script type=…>\r\n\r\n    Старый стандарт HTML, HTML4, требовал наличия этого атрибута в теге <script>. Обычно он имел значение type=\"text/javascript\". На текущий момент этого больше не требуется. Более того, в современном стандарте HTML смысл этого атрибута полностью изменился. Теперь он может использоваться для JavaScript-модулей. Но это тема не для начального уровня, и о ней мы поговорим в другой части учебника.\r\nАтрибут language: <script language=…>\r\n\r\n    Этот атрибут должен был задавать язык, на котором написан скрипт. Но так как JavaScript является языком по умолчанию, в этом атрибуте уже нет необходимости.\r\nОбёртывание скрипта в HTML-комментарии.\r\n\r\n    В очень древних книгах и руководствах вы сможете найти комментарии внутри тега <script>, например, такие:\r\n\r\n    <script type=\"text/javascript\"><!--\r\n        ...\r\n    //--></script>\r\n\r\n    Этот комментарий скрывал код JavaScript в старых браузерах, которые не знали, как обрабатывать тег <script>. Поскольку все браузеры, выпущенные за последние 15 лет, не содержат данной проблемы, такие комментарии уже не нужны. Если они есть, то это признак, что перед нами очень древний код.\r\n\r\nВнешние скрипты\r\n\r\nЕсли у вас много JavaScript-кода, вы можете поместить его в отдельный файл.\r\n\r\nФайл скрипта можно подключить к HTML с помощью атрибута src:\r\n\r\n<script src=\"/path/to/script.js\"></script>\r\n\r\nЗдесь /path/to/script.js – это абсолютный путь от корневой папки до необходимого файла. Корневой папкой может быть корень диска или корень сайта, в зависимости от условий работы сайта. Также можно указать относительный путь от текущей страницы. Например, src=\"script.js\" или src=\"./script.js\" будет означать, что файл \"script.js\" находится в текущей папке.\r\n\r\nМожно указать и полный URL-адрес. Например:\r\n\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js\"></script>\r\n\r\nДля подключения нескольких скриптов используйте несколько тегов:\r\n\r\n<script src=\"/js/script1.js\"></script>\r\n<script src=\"/js/script2.js\"></script>\r\n…\r\n\r\nНа заметку:\r\n\r\nКак правило, только простейшие скрипты помещаются в HTML. Более сложные выделяются в отдельные файлы.\r\n\r\nПольза отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в кеше.\r\n\r\nДругие страницы, которые подключают тот же скрипт, смогут брать его из кеша вместо повторной загрузки из сети. И таким образом файл будет загружаться с сервера только один раз.\r\n\r\nЭто сокращает расход трафика и ускоряет загрузку страниц.\r\nЕсли атрибут src установлен, содержимое тега script будет игнорироваться.\r\n\r\nВ одном теге <script> нельзя использовать одновременно атрибут src и код внутри.\r\n\r\nНижеприведённый пример не работает:\r\n\r\n<script src=\"file.js\">\r\n  alert(1); // содержимое игнорируется, так как есть атрибут src\r\n</script>\r\n\r\nНужно выбрать: либо внешний скрипт <script src=\"…\">, либо обычный код внутри тега <script>.\r\n\r\nВышеприведённый пример можно разделить на два скрипта:\r\n\r\n<script src=\"file.js\"></script>\r\n<script>\r\n  alert(1);\r\n</script>\r\n\r\nИтого\r\n\r\n    Для добавления кода JavaScript на страницу используется тег <script>\r\n    Атрибуты type и language необязательны.\r\n    Скрипт во внешнем файле можно вставить с помощью <script src=\"path/to/script.js\"></script>.\r\n\r\nНам ещё многое предстоит изучить про браузерные скрипты и их взаимодействие со страницей. Но, как уже было сказано, эта часть учебника посвящена именно языку JavaScript, поэтому здесь мы постараемся не отвлекаться на детали реализации в браузере. Мы воспользуемся браузером для запуска JavaScript, это удобно для онлайн-демонстраций, но это только одна из платформ, на которых работает этот язык.'),
(21, 'Структура кода', 'JavaScript', 'https://i.imgur.com/UQijnql.jpg', 'Начнём изучение языка с рассмотрения основных «строительных блоков» кода.\r\nИнструкции\r\n\r\nИнструкции – это синтаксические конструкции и команды, которые выполняют действия.\r\n\r\nМы уже видели инструкцию alert(\"Привет, мир!\"), которая отображает сообщение «Привет, мир!».\r\n\r\nВ нашем коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.\r\n\r\nНапример, здесь мы разделили сообщение «Привет Мир» на два вызова alert:\r\n\r\nalert(\"Привет\"); alert(\"Мир\");\r\n\r\nОбычно каждую инструкцию пишут на новой строке, чтобы код было легче читать:\r\n\r\nalert(\"Привет\");\r\nalert(\"Мир\");\r\n\r\nТочка с запятой\r\n\r\nВ большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.\r\n\r\nТак тоже будет работать:\r\n\r\nalert(\"Привет\")\r\nalert(\"Мир\")\r\n\r\nВ этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.\r\n\r\nВ большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!\r\n\r\nВ некоторых ситуациях новая строка всё же не означает точку с запятой. Например:\r\n\r\nalert(3 +\r\n1\r\n+ 2);\r\n\r\nКод выведет 6, потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что, если строка заканчивается знаком \"+\", значит, это «незавершённое выражение», поэтому точка с запятой не требуется. И в этом случае всё работает, как задумано.\r\n\r\nНо есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна.\r\n\r\nОшибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.\r\nПример ошибки\r\n\r\nЕсли вы хотите увидеть конкретный пример такой ошибки, обратите внимание на этот код:\r\n\r\nalert(\"Hello\");\r\n\r\n[1, 2].forEach(alert);\r\n\r\nПока нет необходимости знать значение скобок [] и forEach. Мы изучим их позже. Пока что просто запомните результат выполнения этого кода: выводится Hello, затем 1, затем 2.\r\n\r\nА теперь давайте уберем точку с запятой после alert:\r\n\r\nalert(\"Hello\")\r\n\r\n[1, 2].forEach(alert);\r\n\r\nЭтот код отличается от кода, приведенного выше, только в одном: пропала точка с запятой в конце первой строки.\r\n\r\nЕсли мы запустим этот код, выведется только первый alert, а затем мы получим ошибку (вам может потребоваться открыть консоль, чтобы увидеть её)!\r\n\r\nЭто потому что JavaScript не вставляет точку с запятой перед квадратными скобками [...]. И поэтому код в последнем примере выполняется, как одна инструкция.\r\n\r\nВот как движок видит его:\r\n\r\nalert(\"Hello\")[1, 2].forEach(alert);\r\n\r\nВыглядит странно, правда? Такое слияние в данном случае неправильное. Мы должны поставить точку с запятой после alert, чтобы код работал правильно.\r\n\r\nЭто может произойти и в некоторых других ситуациях.\r\n\r\nМы рекомендуем ставить точку с запятой между инструкциями, даже если они отделены переносами строк. Это правило широко используется в сообществе разработчиков. Стоит отметить ещё раз – в большинстве случаев можно не ставить точку с запятой. Но безопаснее, особенно для новичка, ставить её.\r\nКомментарии\r\n\r\nСо временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять комментарии, которые бы описывали, что делает код и почему.\r\n\r\nКомментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.\r\n\r\nОднострочные комментарии начинаются с двойной косой черты //.\r\n\r\nЧасть строки после // считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.\r\n\r\nКак здесь:\r\n\r\n// Этот комментарий занимает всю строку\r\nalert(\"Привет\");\r\n\r\nalert(\"Мир\"); // Этот комментарий следует за инструкцией\r\n\r\nМногострочные комментарии начинаются косой чертой со звёздочкой /* и заканчиваются звёздочкой с косой чертой */.\r\n\r\nКак вот здесь:\r\n\r\n/* Пример с двумя сообщениями.\r\nЭто - многострочный комментарий.\r\n*/\r\nalert(\"Привет\");\r\nalert(\"Мир\");\r\n\r\nСодержимое комментария игнорируется, поэтому, если мы поместим код внутри /* … */, он не будет исполняться.\r\n\r\nЭто бывает удобно для временного отключения участка кода:\r\n\r\n/* Закомментировали код\r\nalert(\"Привет\");\r\n*/\r\nalert(\"Мир\");\r\n\r\nИспользуйте горячие клавиши!\r\n\r\nВ большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+/ для однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.\r\nВложенные комментарии не поддерживаются!\r\n\r\nНе может быть /*...*/ внутри /*...*/.\r\n\r\nТакой код «умрёт» с ошибкой:\r\n\r\n/*\r\n  /* вложенный комментарий ?!? */\r\n*/\r\nalert( \"Мир\" );\r\n\r\nНе стесняйтесь использовать комментарии в своём коде.\r\n\r\nКомментарии увеличивают размер кода, но это не проблема. Есть множество инструментов, которые минифицируют код перед публикацией на рабочий сервер. Они убирают комментарии, так что они не содержатся в рабочих скриптах. Таким образом, комментарии никоим образом не вредят рабочему коду.'),
(22, 'Строгий режим — \"use strict\"', 'JavaScript', 'https://i.imgur.com/2zfhWag.jpg', 'На протяжении долгого времени JavaScript развивался без проблем с обратной совместимостью. Новые функции добавлялись в язык, в то время как старая функциональность не менялась.\r\n\r\nПреимуществом данного подхода было то, что существующий код продолжал работать. А недостатком – что любая ошибка или несовершенное решение, принятое создателями JavaScript, застревали в языке навсегда.\r\n\r\nТак было до 2009 года, когда появился ECMAScript 5 (ES5). Он добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: \"use strict\".\r\n«use strict»\r\n\r\nДиректива выглядит как строка: \"use strict\" или \"use strict\". Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме.\r\n\r\nНапример:\r\n\r\n\"use strict\";\r\n\r\n// этот код работает в современном режиме\r\n...\r\n\r\nСовсем скоро мы начнём изучать функции (способ группировки команд), поэтому заранее отметим, что в начале большинства видов функций можно поставить \"use strict\". Это позволяет включить строгий режим только в конкретной функции. Но обычно люди используют его для всего файла.\r\nУбедитесь, что «use strict» находится в начале\r\n\r\nПроверьте, что \"use strict\" находится в первой исполняемой строке скрипта, иначе строгий режим может не включиться.\r\n\r\nЗдесь строгий режим не включён:\r\n\r\nalert(\"some code\");\r\n// \"use strict\" ниже игнорируется - он должен быть в первой строке\r\n\r\n\"use strict\";\r\n\r\n// строгий режим не активирован\r\n\r\nНад \"use strict\" могут быть записаны только комментарии.\r\nНет никакого способа отменить use strict\r\n\r\nНет директивы типа \"no use strict\", которая возвращала бы движок к старому поведению.\r\n\r\nКак только мы входим в строгий режим, отменить это невозможно.\r\nКонсоль браузера\r\n\r\nВ дальнейшем, когда вы будете использовать консоль браузера для тестирования функций, обратите внимание, что use strict по умолчанию в ней выключен.\r\n\r\nИногда, когда use strict имеет значение, вы можете получить неправильные результаты.\r\n\r\nИтак, как можно включить use strict в консоли?\r\n\r\nМожно использовать Shift+Enter для ввода нескольких строк и написать в верхней строке use strict:\r\n\r\n\"use strict\"; <Shift+Enter для перехода на новую строку>\r\n//  ...ваш код...\r\n<Enter для запуска>\r\n\r\nВ большинстве браузеров, включая Chrome и Firefox, это работает.\r\n\r\nЕсли этого не происходит, например, в старом браузере, есть некрасивый, но надежный способ обеспечить use strict. Поместите его в следующую обёртку:\r\n\r\n(function() {\r\n  \"use strict\";\r\n\r\n  // ...ваш код...\r\n})()\r\n\r\nВсегда ли нужно использовать «use strict»?\r\n\r\nВопрос кажется риторическим, но это не так.\r\n\r\nКто-то посоветует начинать каждый скрипт с \"use strict\"… Но есть способ покруче.\r\n\r\nСовременный JavaScript поддерживает «классы» и «модули» — продвинутые структуры языка (и мы, конечно, до них доберёмся), которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву \"use strict\".\r\n\r\nПодытожим: пока очень желательно добавлять \"use strict\"; в начале ваших скриптов. Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать.\r\n\r\nПока мы узнали о use strict только в общих чертах.\r\n\r\nВ следующих главах, по мере расширения знаний о возможностях языка, мы яснее увидим отличия между строгим и стандартным режимом. К счастью, их не так много, и все они делают жизнь разработчика лучше.');
INSERT INTO `article` (`id`, `title`, `genre`, `image`, `description`) VALUES
(23, 'Переменные', 'JavaScript', 'https://i.imgur.com/Z7LV6EI.png', 'JavaScript-приложению обычно нужно работать с информацией. Например:\r\n\r\n    Интернет-магазин – информация может включать продаваемые товары и корзину покупок.\r\n    Чат – информация может включать пользователей, сообщения и многое другое.\r\n\r\nПеременные используются для хранения этой информации.\r\nПеременная\r\n\r\nПеременная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.\r\n\r\nДля создания переменной в JavaScript используйте ключевое слово let.\r\n\r\nПриведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем «message»:\r\n\r\nlet message;\r\n\r\nТеперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания =:\r\n\r\nlet message;\r\n\r\nmessage = \"Hello\"; // сохранить строку \"Hello\" в переменной с именем message\r\n\r\nСтрока сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:\r\n\r\nlet message;\r\nmessage = \"Hello!\";\r\n\r\nalert(message); // показывает содержимое переменной\r\n\r\nДля краткости можно совместить объявление переменной и запись данных в одну строку:\r\n\r\nlet message = \"Hello!\"; // определяем переменную и присваиваем ей значение\r\n\r\nalert(message); // Hello!\r\n\r\nМы также можем объявить несколько переменных в одной строке:\r\n\r\nlet user = \"John\", age = 25, message = \"Hello\";\r\n\r\nТакой способ может показаться короче, но мы не рекомендуем его. Для лучшей читаемости объявляйте каждую переменную на новой строке.\r\n\r\nМногострочный вариант немного длиннее, но легче для чтения:\r\n\r\nlet user = \"John\";\r\nlet age = 25;\r\nlet message = \"Hello\";\r\n\r\nНекоторые люди также определяют несколько переменных в таком вот многострочном стиле:\r\n\r\nlet user = \"John\",\r\n  age = 25,\r\n  message = \"Hello\";\r\n\r\n…Или даже с запятой в начале строки:\r\n\r\nlet user = \"John\"\r\n  , age = 25\r\n  , message = \"Hello\";\r\n\r\nВ принципе, все эти варианты работают одинаково. Так что это вопрос личного вкуса и эстетики.\r\nvar вместо let\r\n\r\nВ старых скриптах вы также можете найти другое ключевое слово: var вместо let:\r\n\r\nvar message = \"Hello\";\r\n\r\nКлючевое слово var – почти то же самое, что и let. Оно объявляет переменную, но немного по-другому, «устаревшим» способом.\r\n\r\nЕсть тонкие различия между let и var, но они пока не имеют для нас значения. Мы подробно рассмотрим их в главе Устаревшее ключевое слово \"var\".\r\nАналогия из жизни\r\n\r\nМы легко поймём концепцию «переменной», если представим её в виде «коробки» для данных с уникальным названием на ней.\r\n\r\nНапример, переменную message можно представить как коробку с названием \"message\" и значением \"Hello!\" внутри:\r\n\r\nМы можем положить любое значение в коробку.\r\n\r\nМы также можем изменить его столько раз, сколько захотим:\r\n\r\nlet message;\r\n\r\nmessage = \"Hello!\";\r\n\r\nmessage = \"World!\"; // значение изменено\r\n\r\nalert(message);\r\n\r\nПри изменении значения старые данные удаляются из переменной:\r\n\r\nМы также можем объявить две переменные и скопировать данные из одной в другую.\r\n\r\nlet hello = \"Hello world!\";\r\n\r\nlet message;\r\n\r\n// копируем значение \"Hello world\" из переменной hello в переменную message\r\nmessage = hello;\r\n\r\n// теперь две переменные содержат одинаковые данные\r\nalert(hello); // Hello world!\r\nalert(message); // Hello world!\r\n\r\nПовторное объявление вызывает ошибку\r\n\r\nПеременная может быть объявлена только один раз.\r\n\r\nПовторное объявление той же переменной является ошибкой:\r\n\r\nlet message = \"Это\";\r\n\r\n// повторение ключевого слова \"let\" приводит к ошибке\r\nlet message = \"Другое\"; // SyntaxError: \"message\" has already been declared\r\n\r\nПоэтому следует объявлять переменную только один раз и затем использовать её уже без let.\r\nФункциональные языки программирования\r\n\r\nПримечательно, что существуют функциональные языки программирования, такие как Scala или Erlang, которые запрещают изменять значение переменной.\r\n\r\nВ таких языках однажды сохранённое «в коробку» значение остаётся там навсегда. Если нам нужно сохранить что-то другое, язык заставляет нас создать новую коробку (объявить новую переменную). Мы не можем использовать старую переменную.\r\n\r\nХотя на первый взгляд это может показаться немного странным, эти языки вполне подходят для серьёзной разработки. Более того, есть такая область, как параллельные вычисления, где это ограничение даёт определённые преимущества. Изучение такого языка (даже если вы не планируете использовать его в ближайшее время) рекомендуется для расширения кругозора.\r\nИмена переменных\r\n\r\nВ JavaScript есть два ограничения, касающиеся имён переменных:\r\n\r\n    Имя переменной должно содержать только буквы, цифры или символы $ и _.\r\n    Первый символ не должен быть цифрой.\r\n\r\nПримеры допустимых имён:\r\n\r\nlet userName;\r\nlet test123;\r\n\r\nЕсли имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.\r\n\r\nСамое интересное – знак доллара \"$\" и подчёркивание \"_\" также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.\r\n\r\nЭти имена являются допустимыми:\r\n\r\nlet $ = 1; // объявили переменную с именем \"$\"\r\nlet _ = 2; // а теперь переменную с именем \"_\"\r\n\r\nalert($ + _); // 3\r\n\r\nПримеры неправильных имён переменных:\r\n\r\nlet 1a; // не может начинаться с цифры\r\n\r\nlet my-name; // дефис \"-\" не разрешён в имени\r\n\r\nРегистр имеет значение\r\n\r\nПеременные с именами apple и APPLE – это две разные переменные.\r\nНелатинские буквы разрешены, но не рекомендуются\r\n\r\nМожно использовать любой язык, включая кириллицу или даже иероглифы, например:\r\n\r\nlet имя = \"...\";\r\nlet 我 = \"...\";\r\n\r\nТехнически здесь нет ошибки, такие имена разрешены, но есть международная традиция использовать английский язык в именах переменных. Даже если мы пишем небольшой скрипт, у него может быть долгая жизнь впереди. Людям из других стран, возможно, придётся прочесть его не один раз.\r\nЗарезервированные имена\r\n\r\nСуществует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.\r\n\r\nНапример: let, class, return и function зарезервированы.\r\n\r\nПриведённый ниже код даёт синтаксическую ошибку:\r\n\r\nlet let = 5; // нельзя назвать переменную \"let\", ошибка!\r\nlet return = 5; // также нельзя назвать переменную \"return\", ошибка!\r\n\r\nСоздание переменной без использования use strict\r\n\r\nОбычно нам нужно определить переменную перед её использованием. Но в старые времена было технически возможно создать переменную простым присвоением значения без использования let. Это все ещё работает, если мы не включаем use strict в наших файлах, чтобы обеспечить совместимость со старыми скриптами.\r\n\r\n// заметка: \"use strict\" в этом примере не используется\r\n\r\nnum = 5; // если переменная \"num\" раньше не существовала, она создаётся\r\n\r\nalert(num); // 5\r\n\r\nЭто плохая практика, которая приводит к ошибке в строгом режиме:\r\n\r\n\"use strict\";\r\n\r\nnum = 5; // ошибка: num is not defined\r\n\r\nКонстанты\r\n\r\nЧтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:\r\n\r\nconst myBirthday = \"18.04.1982\";\r\n\r\nПеременные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:\r\n\r\nconst myBirthday = \"18.04.1982\";\r\n\r\nmyBirthday = \"01.01.2001\"; // ошибка, константу нельзя перезаписать!\r\n\r\nЕсли программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const.\r\nКонстанты в верхнем регистре\r\n\r\nШироко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.\r\n\r\nНазвания таких констант пишутся с использованием заглавных букв и подчёркивания.\r\n\r\nНапример, сделаем константы для различных цветов в «шестнадцатеричном формате»:\r\n\r\nconst COLOR_RED = \"#F00\";\r\nconst COLOR_GREEN = \"#0F0\";\r\nconst COLOR_BLUE = \"#00F\";\r\nconst COLOR_ORANGE = \"#FF7F00\";\r\n\r\n// ...когда нам нужно выбрать цвет\r\nlet color = COLOR_ORANGE;\r\nalert(color); // #FF7F00\r\n\r\nПреимущества:\r\n\r\n    COLOR_ORANGE гораздо легче запомнить, чем \"#FF7F00\".\r\n    Гораздо легче допустить ошибку при вводе \"#FF7F00\", чем при вводе COLOR_ORANGE.\r\n    При чтении кода COLOR_ORANGE намного понятнее, чем #FF7F00.\r\n\r\nКогда мы должны использовать для констант заглавные буквы, а когда называть их нормально? Давайте разберёмся и с этим.\r\n\r\nНазвание «константа» просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.\r\n\r\nНапример:\r\n\r\nconst pageLoadTime = /* время, потраченное на загрузку веб-страницы */;\r\n\r\nЗначение pageLoadTime неизвестно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это всё ещё константа, потому что она не изменяется после назначения.\r\n\r\nДругими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.\r\nПридумывайте правильные имена\r\n\r\nВ разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь.\r\n\r\nНазвание переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.\r\n\r\nИменование переменных – это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой – опытным разработчиком.\r\n\r\nВ реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.\r\n\r\nПожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.\r\n\r\nНесколько хороших правил:\r\n\r\n    Используйте легко читаемые имена, такие как userName или shoppingCart.\r\n    Избегайте использования аббревиатур или коротких имён, таких как a, b, c, за исключением тех случаев, когда вы точно знаете, что так нужно.\r\n    Делайте имена максимально описательными и лаконичными. Примеры плохих имён: data и value. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.\r\n    Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется «user», тогда мы должны называть связанные с ним переменные currentUser или newUser, а не, к примеру, currentVisitor или newManInTown.\r\n\r\nЗвучит просто? Действительно, это так, но на практике для создания описательных и кратких имён переменных зачастую требуется подумать. Действуйте.\r\nПовторно использовать или создавать новую переменную?\r\n\r\nИ последняя заметка. Есть ленивые программисты, которые вместо объявления новых переменных повторно используют существующие.\r\n\r\nВ результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них этикетки. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.\r\n\r\nТакие программисты немного экономят на объявлении переменных, но теряют в десять раз больше при отладке.\r\n\r\nДополнительная переменная – это добро, а не зло.\r\n\r\nСовременные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.\r\nИтого\r\n\r\nМы можем объявить переменные для хранения данных с помощью ключевых слов var, let или const.\r\n\r\n    let – это современный способ объявления.\r\n    var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово \"var\" на случай, если это всё-таки вам понадобится.\r\n    const – похоже на let, но значение переменной не может изменяться.\r\n\r\nПеременные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.'),
(24, 'Типы данных', 'JavaScript', 'https://i.imgur.com/Z7LV6EI.png', 'Значение в JavaScript всегда относится к данным определённого типа. Например, это может быть строка или число.\r\n\r\nЕсть восемь основных типов данных в JavaScript. В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.\r\n\r\nПеременная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:\r\n\r\n// Не будет ошибкой\r\nlet message = \"hello\";\r\nmessage = 123456;\r\n\r\nЯзыки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.\r\nЧисло\r\n\r\nlet n = 123;\r\nn = 12.345;\r\n\r\nЧисловой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.\r\n\r\nСуществует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.\r\n\r\nКроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.\r\n\r\n    Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.\r\n\r\n    Мы можем получить его в результате деления на ноль:\r\n\r\nalert( 1 / 0 ); // Infinity\r\n\r\nИли задать его явно:\r\n\r\nalert( Infinity ); // Infinity\r\n\r\nNaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:\r\n\r\nalert( \"не число\" / 2 ); // NaN, такое деление является ошибкой\r\n\r\nЗначение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:\r\n\r\n    alert( NaN + 1 ); // NaN\r\n    alert( 3 * NaN ); // NaN\r\n    alert( \"не число\" / 2 - 1 ); // NaN\r\n\r\n    Если где-то в математическом выражении есть NaN, то оно распространяется на весь результат (есть только одно исключение: NaN ** 0 равно 1).\r\n\r\nМатематические операции – безопасны\r\n\r\nМатематические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.\r\n\r\nСкрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.\r\n\r\nСпециальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.\r\n\r\nПодробнее о работе с числами мы поговорим в главе Числа.\r\nBigInt\r\n\r\nВ JavaScript тип number не может безопасно работать с числами, большими, чем (253-1) (т. е. 9007199254740991) или меньшими, чем -(253-1) для отрицательных чисел.\r\n\r\nЕсли говорить совсем точно, то, технически, тип number может хранить большие целые числа (до 1.7976931348623157 * 10308), но за пределами безопасного диапазона целых чисел ±(253-1) будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.\r\n\r\nНапример, эти два числа (прямо за пределами безопасного диапазона) совпадают:\r\n\r\nconsole.log(9007199254740991 + 1); // 9007199254740992\r\nconsole.log(9007199254740991 + 2); // 9007199254740992\r\n\r\nТо есть все нечетные целые числа, большие чем (253-1), вообще не могут храниться в типе number.\r\n\r\nВ большинстве случаев безопасного диапазона чисел от -(253-1) до (253-1) вполне достаточно, но иногда нам требуется весь диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени («timestamp») с микросекундами.\r\n\r\nТип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.\r\n\r\nЧтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:\r\n\r\n// символ \"n\" в конце означает, что это BigInt\r\nconst bigInt = 1234567890123456789012345678901234567890n;\r\n\r\nТак как необходимость в использовании BigInt–чисел появляется достаточно редко, мы рассмотрим их в отдельной главе BigInt. Ознакомьтесь с ней, когда вам понадобятся настолько большие числа.\r\nПоддержка\r\n\r\nВ данный момент BigInt поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.\r\nСтрока\r\n\r\nСтрока (string) в JavaScript должна быть заключена в кавычки.\r\n\r\nlet str = \"Привет\";\r\nlet str2 = \"Одинарные кавычки тоже подойдут\";\r\nlet phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;\r\n\r\nВ JavaScript существует три типа кавычек.\r\n\r\n    Двойные кавычки: \"Привет\".\r\n    Одинарные кавычки: \"Привет\".\r\n    Обратные кавычки: `Привет`.\r\n\r\nДвойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.\r\n\r\nОбратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:\r\n\r\nlet name = \"Иван\";\r\n\r\n// Вставим переменную\r\nalert( `Привет, ${name}!` ); // Привет, Иван!\r\n\r\n// Вставим выражение\r\nalert( `результат: ${1 + 2}` ); // результат: 3\r\n\r\nВыражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную name, или выражение 1 + 2, или что-то более сложное.\r\n\r\nОбратите внимание, что это можно делать только в обратных кавычках. Другие кавычки не имеют такой функциональности встраивания!\r\n\r\nalert( \"результат: ${1 + 2}\" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)\r\n\r\nМы рассмотрим строки более подробно в главе Строки.\r\nНет отдельного типа данных для одного символа.\r\n\r\nВ некоторых языках, например C и Java, для хранения одного символа, например \"a\" или \"%\", существует отдельный тип. В языках C и Java это char.\r\n\r\nВ JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.\r\nБулевый (логический) тип\r\n\r\nБулевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).\r\n\r\nТакой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».\r\n\r\nНапример:\r\n\r\nlet nameFieldChecked = true; // да, поле отмечено\r\nlet ageFieldChecked = false; // нет, поле не отмечено\r\n\r\nБулевые значения также могут быть результатом сравнений:\r\n\r\nlet isGreater = 4 > 1;\r\n\r\nalert( isGreater ); // true (результатом сравнения будет \"да\")\r\n\r\nМы рассмотрим булевые значения более подробно в главе Логические операторы.\r\nЗначение «null»\r\n\r\nСпециальное значение null не относится ни к одному из типов, описанных выше.\r\n\r\nОно формирует отдельный тип, который содержит только значение null:\r\n\r\nlet age = null;\r\n\r\nВ JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.\r\n\r\nЭто просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».\r\n\r\nВ приведённом выше коде указано, что значение переменной age неизвестно.\r\nЗначение «undefined»\r\n\r\nСпециальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.\r\n\r\nОно означает, что «значение не было присвоено».\r\n\r\nЕсли переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:\r\n\r\nlet age;\r\n\r\nalert(age); // выведет \"undefined\"\r\n\r\nТехнически мы можем присвоить значение undefined любой переменной:\r\n\r\nlet age = 123;\r\n\r\n// изменяем значение на undefined\r\nage = undefined;\r\n\r\nalert(age); // \"undefined\"\r\n\r\n…Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.\r\nОбъекты и символы\r\n\r\nТип object (объект) – особенный.\r\n\r\nВсе остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.\r\n\r\nОбъекты занимают важное место в языке и требуют особого внимания. Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.\r\n\r\nТип symbol (символ) используется для создания уникальных идентификаторов в объектах. Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.\r\nОператор typeof\r\n\r\nОператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.\r\n\r\nУ него есть две синтаксические формы:\r\n\r\n// Обычный синтаксис\r\ntypeof 5 // Выведет \"number\"\r\n// Синтаксис, напоминающий вызов функции (встречается реже)\r\ntypeof(5) // Также выведет \"number\"\r\n\r\nЕсли передается выражение, то нужно заключать его в скобки, т.к. typeof имеет более высокий приоритет, чем бинарные операторы:\r\n\r\ntypeof 50 + \" Квартир\"; // Выведет \"number Квартир\"\r\ntypeof (50 + \" Квартир\"); // Выведет \"string\"\r\n\r\nДругими словами, скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения в них.\r\n\r\nВызов typeof x возвращает строку с именем типа:\r\n\r\ntypeof undefined // \"undefined\"\r\n\r\ntypeof 0 // \"number\"\r\n\r\ntypeof 10n // \"bigint\"\r\n\r\ntypeof true // \"boolean\"\r\n\r\ntypeof \"foo\" // \"string\"\r\n\r\ntypeof Symbol(\"id\") // \"symbol\"\r\n\r\ntypeof Math // \"object\"  (1)\r\n\r\ntypeof null // \"object\"  (2)\r\n\r\ntypeof alert // \"function\"  (3)\r\n\r\nПоследние три строки нуждаются в пояснении:\r\n\r\n    Math — это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе Числа. Здесь он служит лишь примером объекта.\r\n    Результатом вызова typeof null является \"object\". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.\r\n    Вызов typeof alert возвращает \"function\", потому что alert является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая \"function\". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.\r\n\r\nИтого\r\n\r\nВ JavaScript есть 8 основных типов данных.\r\n\r\n    Семь из них называют «примитивными» типами данных:\r\n        number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).\r\n        bigint для целых чисел произвольной длины.\r\n        string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.\r\n        boolean для true/false.\r\n        null для неизвестных значений – отдельный тип, имеющий одно значение null.\r\n        undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.\r\n        symbol для уникальных идентификаторов.\r\n    И один не является «примитивным» и стоит особняком:\r\n        object для более сложных структур данных.\r\n\r\nОператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.\r\n\r\n    Имеет две формы: typeof x или typeof(x).\r\n    Возвращает строку с именем типа. Например, \"string\".\r\n    Для null возвращается \"object\" – это ошибка в языке, на самом деле это не объект.\r\n\r\nВ следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.'),
(25, 'Взаимодействие: alert, prompt, confirm', 'JavaScript', 'https://i.imgur.com/So9IabD.jpg', 'Так как мы будем использовать браузер как демо-среду, нам нужно познакомиться с несколькими функциями его интерфейса, а именно: alert, prompt и confirm.\r\nalert\r\n\r\nС этой функцией мы уже знакомы. Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».\r\n\r\nНапример:\r\n\r\nalert(\"Hello\");\r\n\r\nЭто небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. В данном случае – пока не будет нажата кнопка «OK».\r\nprompt\r\n\r\nФункция prompt принимает два аргумента:\r\n\r\nresult = prompt(title, [default]);\r\n\r\nЭтот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.\r\n\r\ntitle\r\n    Текст для отображения в окне.\r\ndefault\r\n    Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.\r\n\r\nКвадратные скобки в синтаксисе [...]\r\n\r\nКвадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.\r\n\r\nПользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.\r\n\r\nВызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.\r\n\r\nНапример:\r\n\r\nlet age = prompt(\"Сколько тебе лет?\", 100);\r\n\r\nalert(`Тебе ${age} лет!`); // Тебе 100 лет!\r\n\r\nДля IE: всегда устанавливайте значение по умолчанию\r\n\r\nВторой параметр является необязательным, но если не указать его, то Internet Explorer вставит строку \"undefined\" в поле для ввода.\r\n\r\nЗапустите код в Internet Explorer и посмотрите на результат:\r\n\r\nlet test = prompt(\"Test\");\r\n\r\nЧтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:\r\n\r\nlet test = prompt(\"Test\", \"\"); // <-- для IE\r\n\r\nconfirm\r\n\r\nСинтаксис:\r\n\r\nresult = confirm(question);\r\n\r\nФункция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.\r\n\r\nРезультат – true, если нажата кнопка OK. В других случаях – false.\r\n\r\nНапример:\r\n\r\nlet isBoss = confirm(\"Ты здесь главный?\");\r\n\r\nalert( isBoss ); // true, если нажата OK\r\n\r\nИтого\r\n\r\nМы рассмотрели 3 функции браузера для взаимодействия с пользователем:\r\n\r\nalert\r\n    показывает сообщение.\r\nprompt\r\n    показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.\r\nconfirm\r\n    показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.\r\n\r\nВсе эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.\r\n\r\nНа все указанные методы распространяются два ограничения:\r\n\r\n    Расположение окон определяется браузером. Обычно окна находятся в центре.\r\n    Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.\r\n\r\nТакова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.'),
(27, 'Преобразование типов', 'JavaScript', 'https://i.imgur.com/OM6JzrN.jpg', 'Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.\r\n\r\nНапример, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.\r\n\r\nЕсть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.\r\nПока что мы не говорим об объектах\r\n\r\nВ этой главе мы не касаемся объектов. Сначала мы разберём преобразование примитивных значений.\r\n\r\nМы разберём преобразование объектов позже, в главе Преобразование объектов в примитивы.\r\nСтроковое преобразование\r\n\r\nСтроковое преобразование происходит, когда требуется представление чего-либо в виде строки.\r\n\r\nНапример, alert(value) преобразует значение к строке.\r\n\r\nТакже мы можем использовать функцию String(value), чтобы преобразовать значение к строке:\r\n\r\nlet value = true;\r\nalert(typeof value); // boolean\r\n\r\nvalue = String(value); // теперь value это строка \"true\"\r\nalert(typeof value); // string\r\n\r\nПреобразование происходит очевидным образом. false становится \"false\", null становится \"null\" и т.п.\r\nЧисленное преобразование\r\n\r\nЧисленное преобразование происходит в математических функциях и выражениях.\r\n\r\nНапример, когда операция деления / применяется не к числу:\r\n\r\nalert( \"6\" / \"2\" ); // 3, строки преобразуются в числа\r\n\r\nМы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:\r\n\r\nlet str = \"123\";\r\nalert(typeof str); // string\r\n\r\nlet num = Number(str); // становится числом 123\r\n\r\nalert(typeof num); // number\r\n\r\nЯвное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.\r\n\r\nЕсли строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:\r\n\r\nlet age = Number(\"Любая строка вместо числа\");\r\n\r\nalert(age); // NaN, преобразование не удалось\r\n\r\nПравила численного преобразования:\r\nЗначение 	Преобразуется в…\r\nundefined 	NaN\r\nnull 	0\r\ntrue / false 	1 / 0\r\nstring 	Пробельные символы (пробелы, знаки табуляции 	, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.\r\n\r\nПримеры:\r\n\r\nalert( Number(\"   123   \") ); // 123\r\nalert( Number(\"123z\") );      // NaN (ошибка чтения числа на месте символа \"z\")\r\nalert( Number(true) );        // 1\r\nalert( Number(false) );       // 0\r\n\r\nУчтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.\r\n\r\nБольшинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.\r\nЛогическое преобразование\r\n\r\nЛогическое преобразование самое простое.\r\n\r\nПроисходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями), но также может быть выполнено явно с помощью функции Boolean(value).\r\n\r\nПравило преобразования:\r\n\r\n    Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.\r\n    Все остальные значения становятся true.\r\n\r\nНапример:\r\n\r\nalert( Boolean(1) ); // true\r\nalert( Boolean(0) ); // false\r\n\r\nalert( Boolean(\"Привет!\") ); // true\r\nalert( Boolean(\"\") ); // false\r\n\r\nЗаметим, что строка с нулём \"0\" — это true\r\n\r\nНекоторые языки (к примеру, PHP) воспринимают строку \"0\" как false. Но в JavaScript, если строка не пустая, то она всегда true.\r\n\r\nalert( Boolean(\"0\") ); // true\r\nalert( Boolean(\" \") ); // пробел это тоже true (любая непустая строка это true)\r\n\r\nИтого\r\n\r\nСуществует 3 наиболее широко используемых преобразования: строковое, численное и логическое.\r\n\r\nСтроковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.\r\n\r\nЧисленное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).\r\n\r\nПреобразование подчиняется правилам:\r\nЗначение 	Становится…\r\nundefined 	NaN\r\nnull 	0\r\ntrue / false 	1 / 0\r\nstring 	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.\r\n\r\nЛогическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).\r\n\r\nПодчиняется правилам:\r\nЗначение 	Становится…\r\n0, null, undefined, NaN, \"\" 	false\r\nлюбое другое значение 	true\r\n\r\nБольшую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:\r\n\r\n    undefined при численном преобразовании становится NaN, не 0.\r\n    \"0\" и строки из одних пробелов типа \" \" при логическом преобразовании всегда true.\r\n'),
(28, 'Структура кода', 'JavaScript', 'https://i.imgur.com/K5ozNhY.jpg', 'Многие операторы знакомы нам ещё со школы: сложение +, умножение *, вычитание - и так далее.\r\n\r\nВ этой главе мы начнём с простых операторов, а потом сконцентрируемся на специфических для JavaScript аспектах, которые не проходят в школьном курсе арифметики.\r\nТермины: «унарный», «бинарный», «операнд»\r\n\r\nПрежде, чем мы двинемся дальше, давайте разберёмся с терминологией.\r\n\r\n    Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».\r\n\r\n    Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус \"-\" меняет знак числа на противоположный:\r\n\r\nlet x = 1;\r\n\r\nx = -x;\r\nalert( x ); // -1, применили унарный минус\r\n\r\nБинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:\r\n\r\n    let x = 1, y = 3;\r\n    alert( y - x ); // 2, бинарный минус вычитает значения\r\n\r\n    Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).\r\n\r\nМатематика\r\n\r\nПоддерживаются следующие математические операторы:\r\n\r\n    Сложение +,\r\n    Вычитание -,\r\n    Умножение *,\r\n    Деление /,\r\n    Взятие остатка от деления %,\r\n    Возведение в степень **.\r\n\r\nПервые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.\r\nВзятие остатка %\r\n\r\nОператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.\r\n\r\nРезультат a % b – это остаток от целочисленного деления a на b.\r\n\r\nНапример:\r\n\r\nalert( 5 % 2 ); // 1, остаток от деления 5 на 2\r\nalert( 8 % 3 ); // 2, остаток от деления 8 на 3\r\nalert( 8 % 4 ); // 0, остаток от деления 8 на 4\r\n\r\nВозведение в степень **\r\n\r\nОператор возведения в степень a ** b возводит a в степень b.\r\n\r\nВ школьной математике мы записываем это как ab.\r\n\r\nНапример:\r\n\r\nalert( 2 ** 2 ); // 2² = 4\r\nalert( 2 ** 3 ); // 2³ = 8\r\nalert( 2 ** 4 ); // 2⁴ = 16\r\n\r\nМатематически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень ½:\r\n\r\nalert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)\r\n\r\nСложение строк при помощи бинарного +\r\n\r\nДавайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики.\r\n\r\nОбычно при помощи плюса \"+\" складывают числа.\r\n\r\nНо если бинарный оператор \"+\" применить к строкам, то он их объединяет в одну:\r\n\r\nlet s = \"моя\" + \"строка\";\r\nalert(s); // моястрока\r\n\r\nОбратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.\r\n\r\nНапример:\r\n\r\nalert( \"1\" + 2 ); // \"12\"\r\nalert( 2 + \"1\" ); // \"21\"\r\n\r\nКак видите, не важно, первый или второй операнд является строкой.\r\n\r\nВот пример посложнее:\r\n\r\nalert(2 + 2 + \"1\" ); // будет \"41\", а не \"221\"\r\n\r\nЗдесь операторы работают один за другим. Первый + складывает два числа и возвращает 4, затем следующий + объединяет результат со строкой, производя действие 4 + \"1\" = \"41\".\r\n\r\nСложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.\r\n\r\nНапример, вычитание и деление:\r\n\r\nalert( 6 - \"2\" ); // 4, \"2\" приводится к числу\r\nalert( \"6\" / \"2\" ); // 3, оба операнда приводятся к числам\r\n\r\nПриведение к числу, унарный +\r\n\r\nПлюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.\r\n\r\nУнарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.\r\n\r\nНапример:\r\n\r\n// Не влияет на числа\r\nlet x = 1;\r\nalert( +x ); // 1\r\n\r\nlet y = -2;\r\nalert( +y ); // -2\r\n\r\n// Преобразует не числа в числа\r\nalert( +true ); // 1\r\nalert( +\"\" );   // 0\r\n\r\nНа самом деле это то же самое, что и Number(...), только короче.\r\n\r\nНеобходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?\r\n\r\nБинарный плюс сложит их как строки:\r\n\r\nlet apples = \"2\";\r\nlet oranges = \"3\";\r\n\r\nalert( apples + oranges ); // \"23\", так как бинарный плюс объединяет строки\r\n\r\nПоэтому используем унарный плюс, чтобы преобразовать к числу:\r\n\r\nlet apples = \"2\";\r\nlet oranges = \"3\";\r\n\r\n// оба операнда предварительно преобразованы в числа\r\nalert( +apples + +oranges ); // 5\r\n\r\n// более длинный вариант\r\n// alert( Number(apples) + Number(oranges) ); // 5\r\n\r\nС точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный \"+\" их сложит.\r\n\r\nПочему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.\r\nПриоритет операторов\r\n\r\nВ том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов.\r\n\r\nИз школы мы знаем, что умножение в выражении 1 + 2 * 2 выполнится раньше сложения. Это как раз и есть «приоритет». Говорят, что умножение имеет более высокий приоритет, чем сложение.\r\n\r\nСкобки важнее, чем приоритет, так что, если мы не удовлетворены порядком по умолчанию, мы можем использовать их, чтобы изменить приоритет. Например, написать (1 + 2) * 2.\r\n\r\nВ JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.\r\n\r\nОтрывок из таблицы приоритетов (нет необходимости всё запоминать, обратите внимание, что приоритет унарных операторов выше, чем соответствующих бинарных):\r\nПриоритет 	Название 	Обозначение\r\n… 	… 	…\r\n15 	унарный плюс 	+\r\n15 	унарный минус 	-\r\n14 	возведение в степень 	**\r\n13 	умножение 	*\r\n13 	деление 	/\r\n12 	сложение 	+\r\n12 	вычитание 	-\r\n… 	… 	…\r\n2 	присваивание 	=\r\n… 	… 	…\r\n\r\nТак как «унарный плюс» имеет приоритет 15, который выше, чем 12 у «сложения» (бинарный плюс), то в выражении \"+apples + +oranges\" сначала выполнятся унарные плюсы, а затем сложение.\r\nПрисваивание\r\n\r\nДавайте отметим, что в таблице приоритетов также есть оператор присваивания =. У него один из самых низких приоритетов: 2.\r\n\r\nИменно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем произойдёт присваивание = с сохранением результата в x.\r\n\r\nlet x = 2 * 2 + 1;\r\n\r\nalert( x ); // 5\r\n\r\nПрисваивание = возвращает значение\r\n\r\nТот факт, что = является оператором, а не «магической» конструкцией языка, имеет интересные последствия.\r\n\r\nБольшинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *. Но и оператор присваивания не является исключением.\r\n\r\nВызов x = value записывает value в x и возвращает его.\r\n\r\nБлагодаря этому присваивание можно использовать как часть более сложного выражения:\r\n\r\nlet a = 1;\r\nlet b = 2;\r\n\r\nlet c = 3 - (a = b + 1);\r\n\r\nalert( a ); // 3\r\nalert( c ); // 0\r\n\r\nВ примере выше результатом (a = b + 1) будет значение, которое присваивается переменной a (то есть 3). Потом оно используется для дальнейших вычислений.\r\n\r\nЗабавное применение присваивания, не так ли? Нам нужно понимать, как это работает, потому что иногда это можно увидеть в JavaScript-библиотеках.\r\n\r\nОднако писать самим в таком стиле не рекомендуется. Такие трюки не сделают ваш код более понятным или читабельным.\r\nПрисваивание по цепочке\r\n\r\nРассмотрим ещё одну интересную возможность: цепочку присваиваний.\r\n\r\nlet a, b, c;\r\n\r\na = b = c = 2 + 2;\r\n\r\nalert( a ); // 4\r\nalert( b ); // 4\r\nalert( c ); // 4\r\n\r\nТакое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается переменным слева: c, b и a. В конце у всех переменных будет одно значение.\r\n\r\nОпять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:\r\n\r\nc = 2 + 2;\r\nb = c;\r\na = c;\r\n\r\nПольза от такого стиля особенно ощущается при быстром просмотре кода.\r\nСокращённая арифметика с присваиванием\r\n\r\nЧасто нужно применить оператор к переменной и сохранить результат в ней же.\r\n\r\nНапример:\r\n\r\nlet n = 2;\r\nn = n + 5;\r\nn = n * 2;\r\n\r\nЭту запись можно укоротить при помощи совмещённых операторов += и *=:\r\n\r\nlet n = 2;\r\nn += 5; // теперь n = 7 (работает как n = n + 5)\r\nn *= 2; // теперь n = 14 (работает как n = n * 2)\r\n\r\nalert( n ); // 14\r\n\r\nПодобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -=, **= и так далее.\r\n\r\nВызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:\r\n\r\nlet n = 2;\r\n\r\nn *= 3 + 5;\r\n\r\nalert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)\r\n\r\nИнкремент/декремент\r\n\r\nОдной из наиболее частых числовых операций является увеличение или уменьшение на единицу.\r\n\r\nДля этого существуют даже специальные операторы:\r\n\r\n    Инкремент ++ увеличивает переменную на 1:\r\n\r\nlet counter = 2;\r\ncounter++;        // работает как counter = counter + 1, просто запись короче\r\nalert( counter ); // 3\r\n\r\nДекремент -- уменьшает переменную на 1:\r\n\r\n    let counter = 2;\r\n    counter--;        // работает как counter = counter - 1, просто запись короче\r\n    alert( counter ); // 1\r\n\r\nВажно:\r\n\r\nИнкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.\r\n\r\nОператоры ++ и -- могут быть расположены не только после, но и до переменной.\r\n\r\n    Когда оператор идёт после переменной — это «постфиксная форма»: counter++.\r\n    «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.\r\n\r\nОбе эти инструкции делают одно и то же: увеличивают counter на 1.\r\n\r\nЕсть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают ++/--.\r\n\r\nДавайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).\r\n\r\nЧтобы увидеть разницу, вот небольшой пример:\r\n\r\nlet counter = 1;\r\nlet a = ++counter; // (*)\r\n\r\nalert(a); // 2\r\n\r\nВ строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.\r\n\r\nТеперь посмотрим на постфиксную форму:\r\n\r\nlet counter = 1;\r\nlet a = counter++; // (*) меняем ++counter на counter++\r\n\r\nalert(a); // 1\r\n\r\nВ строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1.\r\n\r\nПодведём итоги:\r\n\r\n    Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:\r\n\r\nlet counter = 0;\r\ncounter++;\r\n++counter;\r\nalert( counter ); // 2, обе строки сделали одно и то же\r\n\r\nЕсли хочется тут же использовать результат, то нужна префиксная форма:\r\n\r\nlet counter = 0;\r\nalert( ++counter ); // 1\r\n\r\nЕсли нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:\r\n\r\n    let counter = 0;\r\n    alert( counter++ ); // 0\r\n\r\nИнкремент/декремент можно использовать в любых выражениях\r\n\r\nОператоры ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.\r\n\r\nНапример:\r\n\r\nlet counter = 1;\r\nalert( 2 * ++counter ); // 4\r\n\r\nСравните с:\r\n\r\nlet counter = 1;\r\nalert( 2 * counter++ ); // 2, потому что counter++ возвращает \"старое\" значение\r\n\r\nХотя технически здесь всё в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет множество действий – нехорошо.\r\n\r\nПри беглом чтении кода можно с лёгкостью пропустить такой counter++, и будет неочевидно, что переменная увеличивается.\r\n\r\nЛучше использовать стиль «одна строка – одно действие»:\r\n\r\nlet counter = 1;\r\nalert( 2 * counter );\r\ncounter++;\r\n\r\nПобитовые операторы\r\n\r\nПобитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.\r\n\r\nЭти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.\r\n\r\nПоддерживаются следующие побитовые операторы:\r\n\r\n    AND(и) ( & )\r\n    OR(или) ( | )\r\n    XOR(побитовое исключающее или) ( ^ )\r\n    NOT(не) ( ~ )\r\n    LEFT SHIFT(левый сдвиг) ( << )\r\n    RIGHT SHIFT(правый сдвиг) ( >> )\r\n    ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )\r\n\r\nОни используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны.\r\n\r\nВы можете прочитать о них в главе Побитовые операторы, когда возникнет реальная необходимость.\r\nОператор «запятая»\r\n\r\nОператор «запятая» (,) редко применяется и является одним из самых необычных. Иногда он используется для написания более короткого кода, поэтому нам нужно знать его, чтобы понимать, что при этом происходит.\r\n\r\nОператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.\r\n\r\nНапример:\r\n\r\nlet a = (1 + 2, 3 + 4);\r\n\r\nalert( a ); // 7 (результат вычисления 3 + 4)\r\n\r\nПервое выражение 1 + 2 выполняется, а результат отбрасывается. Затем идёт 3 + 4, выражение выполняется и возвращается результат.\r\nЗапятая имеет очень низкий приоритет\r\n\r\nПожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.\r\n\r\nПопробуйте запустить следующий код (строгий режим \"use strict\" в примере ниже не используется, иначе мы бы получили ошибку):\r\n\r\na = 1 + 2, 3 + 4;\r\n\r\nalert(a); // 3\r\n\r\nНеобычный результат, правда? Особенно учитывая то, что оператор , должен «выполнять каждое выражение, но возвращать результат только последнего».\r\n\r\nБез скобок в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет проигнорировано. Всё так же, как в (a = 1 + 2), 3 + 4.\r\n\r\nЗачем нам оператор, который отбрасывает всё, кроме последнего выражения?\r\n\r\nИногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.\r\n\r\nНапример:\r\n\r\n// три операции в одной строке\r\nfor (a = 1, b = 3, c = a * b; a < 10; a++) {\r\n ...\r\n}\r\n\r\nТакие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, поэтому стоит хорошо подумать, прежде чем их использовать.');
INSERT INTO `article` (`id`, `title`, `genre`, `image`, `description`) VALUES
(29, 'Структура программы', 'C#', 'https://i.imgur.com/LbFrEd8.png', 'Выполнение программы\r\n\r\nВесь код программы на языке C# помещается в файлы с расширением .cs. По умолчанию в проекте, который создается в Visual Studio (а также при использовании .NET CLI) уже есть один файл с кодом C# - файл Program.cs со следующим содержимым:\r\n1\r\n2\r\n	\r\n// See https://aka.ms/new-console-template for more information\r\nConsole.WriteLine(\"Hello, World!\");\r\nВыполнение программы на языке программирования C#\r\n\r\nИменно код файла Program.cs выполняется по умолчанию, если мы запустим проект на выполнение. Но при необходимости мы также можем добавлять другие файлы с кодом C#.\r\nИнструкции\r\n\r\nБазовым строительным блоком программы являются инструкции (statement). Инструкция представляет некоторое действие, например, арифметическую операцию, вызов метода, объявление переменной и присвоение ей значения. В конце каждой инструкции в C# ставится точка с запятой (;). Данный знак указывает компилятору на конец инструкции. Например, в проекте консольного приложения, который создается по умолчанию, есть такая строка:\r\n1\r\n	\r\nConsole.WriteLine(\"Hello, World!\");\r\n\r\nДанная строка представляет вызов метода Console.WriteLine, который выводит на консоль строку. В данном случае вызов метода является инструкцией и поэтому завершается точкой с запятой.\r\n\r\nНабор инструкций может объединяться в блок кода. Блок кода заключается в фигурные скобки, а инструкции помещаются между открывающей и закрывающей фигурными скобками. Например, изменим код файла Program.cs на следующий:\r\n1\r\n2\r\n3\r\n4\r\n	\r\n{\r\n    Console.WriteLine(\"Привет\");\r\n    Console.WriteLine(\"Добро пожаловать в C#\");\r\n}\r\nБлок кода на языке программирования C#\r\n\r\nЗдесь блок кода содержит две инструкции. И при выполении этого кода, консоль выведет две строки\r\n\r\nПривет\r\nДобро пожаловать в C#\r\n\r\nВ данном блоке кода две инструкции, которые выводят на консоль определенную строку.\r\n\r\nОдни блоки кода могут содержать другие блоки:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n	\r\n{\r\n    Console.WriteLine(\"Первый блок\");\r\n    {\r\n        Console.WriteLine(\"Второй блок\");\r\n    }\r\n}\r\nРегистрозависимость\r\n\r\nC# является регистрозависимым языком. Это значит, что в зависимости от регистра символов какие-то определенные названия могут представлять разные классы, методы, переменные и т.д. Например, для вывода на консоль используется метод WriteLine - его имя начинается именно с большой буквы: \"WriteLine\". Если мы вместо \"Console.WriteLine\" напишем \"Console.writeline\", то программа не скомпилируется, так как данный метод обязательно должен называться \"WriteLine\", а не \"writeline\" или \"WRITELINE\" или как-то иначе.\r\nКомментарии\r\n\r\nВажной частью программного кода являются комментарии. Они не являются собственно частью программы, при компиляции они игнорируются. Тем не менее комментарии делают код программы более понятным, помогая понять те или иные его части.\r\n\r\nесть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша //. А многострочный комментарий заключается между символами /* текст комментария */. Он может размещаться на нескольких строках. Например:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n	\r\n/*\r\n       первая программа на C#,\r\n       которая выводит приветствие на консоль\r\n*/\r\nConsole.WriteLine(\"Привет\");                // Выводим строку \"Привет\"\r\nConsole.WriteLine(\"Добро пожаловать в C#\"); // Выводим строку \"Добро пожаловать в C#\"\r\nФайл проекта\r\n\r\nВ каждом проекте проекте C# есть файл, который отвечает за общую конфгурацию проекта. По умолчанию этот файл называется Название_проекта.csproj. Итак, откроем данный файл. Для этого либо двойным кликом левой кнопкой мыши нажмем на название проекта, либо нажмем на название проекта правой кнопкой мыши и в появившемся меню выберем пункт Edit Project File\r\nФайл проекта в C# в Visual Studio\r\n\r\nПосле этого Visual Studio откроет нам файл проекта, который будет выглядеть следующим образом:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n	\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n \r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net6.0</TargetFramework>\r\n    <ImplicitUsings>enable</ImplicitUsings>\r\n    <Nullable>enable</Nullable>\r\n  </PropertyGroup>\r\n \r\n</Project>\r\n\r\nЭтот файл в виде кода xml определяет конфгурацию проекта и он может содержать множество элементов. Остановлюсь только на двух основных:\r\n\r\n    OutputType: определяет выходной тип проекта. Это может быть выполняемое приложение в виде файла с расширением exe, которое запускается по нажатию. И также это может быть файл с расширением .dll - некоторый набор функциональностей, который используется другими проектами. По умолчанию здесь установлено значение \"Exe\", что значит, что мы создаем исполняемое приложение.\r\n\r\n    TargetFramework: определяет применяемую для компиляции версию фреймворка .NET. В данном случае это значение \"net6.0\", то есть применяется .NET 6.0.\r\n\r\nНа самых ранних этапах этот файл может не понадобиться, однако впоследствии может потребоваться внести некоторые изменения в конфигурацию, и тогда может возникнуть потребность в обращении к этому файлу.'),
(30, 'Переменные и константы', 'C#', 'https://i.imgur.com/uSi3SIL.jpg', 'Для хранения данных в программе применяются переменные. Переменная представляет именнованную область памяти, в которой хранится значение определенного типа. Переменная имеет тип, имя и значение. Тип определяет, какого рода информацию может хранить переменная.\r\n\r\nПеред использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:\r\n1\r\n	\r\nтип имя_переменной;\r\n\r\nВначале идет тип переменной, потом ее имя. В качестве имени переменной может выступать любое произвольное название, которое удовлетворяет следующим требованиям:\r\n\r\n    имя может содержать любые цифры, буквы и символ подчеркивания, при этом первый символ в имени должен быть буквой или символом подчеркивания\r\n\r\n    в имени не должно быть знаков пунктуации и пробелов\r\n\r\n    имя не может быть ключевым словом языка C#. Таких слов не так много, и при работе в Visual Studio среда разработки подсвечивает ключевые слова синим цветом.\r\n\r\nХотя имя переменой может быть любым, но следует давать переменным описательные имена, которые будут говорить об их предназначении.\r\n\r\nНапример, определим простейшую переменную:\r\n1\r\n	\r\nstring name;\r\n\r\nВ данном случае определена переменная name, которая имеет тип string. то есть переменная представляет строку. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.\r\n\r\nПри этом следует учитывать, что C# является регистрозависимым языком, поэтому следующие два определения переменных будут представлять две разные переменные:\r\n1\r\n2\r\n	\r\nstring name;\r\nstring Name;\r\n\r\nПосле определения переменной можно присвоить некоторое значение:\r\n1\r\n2\r\n	\r\nstring name;\r\nname = \"Tom\";\r\n\r\nТак как переменная name представляет тип string, то есть строку, то мы можем присвоить ей строку в двойных кавычках. Причем переменной можно присвоить только то значение, которое соответствует ее типу.\r\n\r\nВ дальнейшем с помощью имени переменной мы сможем обращаться к той области памяти, в которой хранится ее значение.\r\n\r\nТакже мы можем сразу при определении присвоить переменной значение. Данный прием называется инициализацией:\r\n1\r\n	\r\nstring name = \"Tom\";\r\n\r\nОтличительной чертой переменных является то, что в программе можно многократно менять их значение. Например, создадим небольшую программу, в которой определим переменную, поменяем ее значение и выведем его на консоль:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n	\r\nstring name = \"Tom\";  // определяем переменную и инициализируем ее\r\n  \r\nConsole.WriteLine(name);    // Tom\r\n  \r\nname = \"Bob\";       // меняем значение переменной\r\nConsole.WriteLine(name);    // Bob\r\n\r\nКонсольный вывод программы:\r\n\r\nTom\r\nBob\r\n\r\nКонстанты\r\n\r\nОтличительной особенностью переменных является то, что мы можем изменить их значение в процессе работы программы. Но, кроме того, в C# есть константы. Константа должна быть обязательно инициализирована при определении, и после определения значение константы не может быть изменено\r\n\r\nКонстанты предназначены для описания таких значений, которые не должны изменяться в программе. Для определения констант используется ключевое слово const, которое указывается перед типом константы:\r\n1\r\n	\r\nconst string NAME = \"Tom\";  // определяем константу\r\n\r\nТак, в данном случае определена константа NAME, которая хранит строку \"Tom\". Нередко для название констант используется верхний регистр, но это не более чем условность.\r\n\r\nПри использовании констант надо помнить, что объявить мы их можем только один раз и что к моменту компиляции они должны быть определены. Так, в следующем случае мы получим ошибку, так как константе не присвоено начальное значение:\r\n1\r\n	\r\nconst string NAME;  // ! Ошибка - константа NAME не инициализирована\r\n\r\nКроме того, мы ее не сможем изменить в процессе работы программы:\r\n1\r\n2\r\n	\r\nconst string NAME = \"Tom\";  // определяем константу\r\nNAME = \"Bob\";   // !Ошибка - у констаты нельзя изменить значение\r\n\r\nТаким образом, если нам надо хранить в программе некоторые данные, но их не следует изменить, они определяются в виде констант. Если же их можно изменять, то они определяются в виде переменных.'),
(31, 'Литералы', 'C#', 'https://i.imgur.com/asxVLYG.jpg', 'Литералы представляют неизменяемые значения (иногда их еще называют константами). Литералы можно передавать переменным в качестве значения. Литералы бывают логическими, целочисленными, вещественными, символьными и строчными. И отдельный литерал представляет ключевое слово null.\r\nЛогические литералы\r\n\r\nЕсть две логических константы - true (истина) и false (ложь):\r\n1\r\n2\r\n	\r\nConsole.WriteLine(true);\r\nConsole.WriteLine(false);\r\nЦелочисленные литералы\r\n\r\nЦелочисленные литералы представляют положительные и отрицательные целые числа, например, 1, 2, 3, 4, -7, -109. Целочисленные литералы могут быть выражены в десятичной, шестнадцатеричной и двоичной форме.\r\n\r\nС целыми числами в десятичной форме все должно быть понятно, так как они используются в повседневной жизни:\r\n1\r\n2\r\n3\r\n	\r\nConsole.WriteLine(-11);\r\nConsole.WriteLine(5);\r\nConsole.WriteLine(505);\r\n\r\nЧисла в двоичной форме предваряются символами 0b, после которых идет набор из нулей и единиц:\r\n1\r\n2\r\n3\r\n	\r\nConsole.WriteLine(0b11);        // 3\r\nConsole.WriteLine(0b1011);      // 11\r\nConsole.WriteLine(0b100001);    // 33\r\n\r\nДля записи числа в шестнадцатеричной форме применяются символы 0x, после которых идет набор символов от 0 до 9 и от A до F, которые собственно представляют число:\r\n1\r\n2\r\n3\r\n	\r\nConsole.WriteLine(0x0A);    // 10\r\nConsole.WriteLine(0xFF);    // 255\r\nConsole.WriteLine(0xA1);    // 161\r\nВещественные литералы\r\n\r\nВещественные литералы представляют дробные числа. Этот тип литералов имеет две формы. Первая форма - вещественные числа с фиксированной запятой, при которой дробную часть отделяется от целой части точкой. Например:\r\n1\r\n2\r\n3\r\n	\r\n3.14\r\n100.001\r\n-0.38\r\n\r\nТакже вещественные литералы могут определяться в экспоненциальной форме MEp, где M — мантисса, E - экспонента, которая фактически означает \"*10^\" (умножить на десять в степени), а p — порядок. Например:\r\n1\r\n2\r\n	\r\nConsole.WriteLine(3.2e3);   // по сути равно 3.2 * 10<sup>3</sup> = 3200\r\nConsole.WriteLine(1.2E-1);  // равно 1.2 * 10<sup>-1</sup> = 0.12\r\nСимвольные литералы\r\n\r\nСимвольные литералы представляют одиночные символы. Символы заключаются в одинарные кавычки.\r\n\r\nСимвольные литералы бывают нескольких видов. Прежде всего это обычные символы:\r\n1\r\n2\r\n3\r\n	\r\n\"2\"\r\n\"A\"\r\n\"T\"\r\n\r\nТакже мы можем передать их вывести на консоль с помощью Console.WriteLine:\r\n1\r\n2\r\n3\r\n	\r\nConsole.WriteLine(\"2\");\r\nConsole.WriteLine(\"A\");\r\nConsole.WriteLine(\"T\");\r\n\r\nСпециальную группу представляют управляющие последовательности Управляющая последовательность представляет символ, перед которым ставится слеш. И данная последовательность интерпретируется определенным образом. Наиболее часто используемые последовательности:\r\n\r\n    \"n\" - перевод строки\r\n\r\n    \"t\" - табуляция\r\n\r\n    \"\" - слеш\r\n\r\nИ если компилятор встретит в тексте последовательность t, то он будет воспринимать эту последовательность не как слеш и букву t, а как табуляцию - то есть длинный отступ.\r\n\r\nТакже символы могут определяться в виде шестнадцатеричных кодов, также заключенный в одинарные кавычки.\r\n\r\nЕще один способ определения символов представляет использования шестнадцатеричных кодов ASCII. Для этого в одинарных кавычках указываются символы \"x\", после которых идет шестнадцатеричный код символа из таблицы ASCII. Коды символов из таблицы ASCII можно посмотреть здесь.\r\n\r\nНапример, литерал \"x78\" представляет символ \"x\":\r\n1\r\n2\r\n	\r\nConsole.WriteLine(\"x78\");    // x\r\nConsole.WriteLine(\"x5A\");    // Z\r\n\r\nИ последний способ определения символьных литералов представляет применение кодов из таблицы символов Unicode. Для этого в одинарных кавычках указываются символы \"u\", после которых идет шестнадцатеричный код Unicode. Например, код \"u0411\" представляет кириллический символ \"Б\":\r\n1\r\n2\r\n	\r\nConsole.WriteLine(\"u0420\");    // Р\r\nConsole.WriteLine(\"u0421\");    // С\r\nСтроковые литералы\r\n\r\nСтроковые литералы представляют строки. Строки заключаются в двойные кавычки:\r\n1\r\n2\r\n3\r\n	\r\nConsole.WriteLine(\"hello\");\r\nConsole.WriteLine(\"фыва\");\r\nConsole.WriteLine(\"hello word\");\r\n\r\nЕсли внутри строки необходимо вывести двойную кавычку, то такая внутренняя кавычка предваряется обратным слешем:\r\n1\r\n	\r\nConsole.WriteLine(\"Компания \"Рога и копыта\"\");\r\n\r\nТакже в строках можно использовать управляющие последовательности. Например, последовательность \"n\" осуществляет перевод на новую строку:\r\n1\r\n	\r\nConsole.WriteLine(\"Привет nмир\");\r\n\r\nПри выводе на консоль слово \"мир\" будет перенесено на новую строку:\r\n\r\nПривет\r\nмир\r\n\r\nnull\r\n\r\nnull представляет ссылку, которая не указывает ни на какой объект. То есть по сути отсутствие значения.\"'),
(32, 'Типы данных', 'C#', 'https://i.imgur.com/5JYSTJa.jpg', 'Как и во многих языках программирования, в C# есть своя система типов данных, которая используется для создания переменных. Тип данных определяет внутреннее представление данных, множество значений, которые может принимать объект, а также допустимые действия, которые можно применять над объектом.\r\n\r\nВ языке C# есть следующие базовые типы данных:\r\n\r\n    bool: хранит значение true или false (логические литералы). Представлен системным типом System.Boolean\r\n    1\r\n    2\r\n    	\r\n    bool alive = true;\r\n    bool isDead = false;\r\n\r\n    byte: хранит целое число от 0 до 255 и занимает 1 байт. Представлен системным типом System.Byte\r\n    1\r\n    2\r\n    	\r\n    byte bit1 = 1;\r\n    byte bit2 = 102;\r\n\r\n    sbyte: хранит целое число от -128 до 127 и занимает 1 байт. Представлен системным типом System.SByte\r\n    1\r\n    2\r\n    	\r\n    sbyte bit1 = -101;\r\n    sbyte bit2 = 102;\r\n\r\n    short: хранит целое число от -32768 до 32767 и занимает 2 байта. Представлен системным типом System.Int16\r\n    1\r\n    2\r\n    	\r\n    short n1 = 1;\r\n    short n2 = 102;\r\n\r\n    ushort: хранит целое число от 0 до 65535 и занимает 2 байта. Представлен системным типом System.UInt16\r\n    1\r\n    2\r\n    	\r\n    ushort n1 = 1;\r\n    ushort n2 = 102;\r\n\r\n    int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта. Представлен системным типом System.Int32. Все целочисленные литералы по умолчанию представляют значения типа int:\r\n    1\r\n    2\r\n    3\r\n    	\r\n    int a = 10;\r\n    int b = 0b101;  // бинарная форма b =5\r\n    int c = 0xFF;   // шестнадцатеричная форма c = 255\r\n\r\n    uint: хранит целое число от 0 до 4294967295 и занимает 4 байта. Представлен системным типом System.UInt32\r\n    1\r\n    2\r\n    3\r\n    	\r\n    uint a = 10;\r\n    uint b = 0b101;\r\n    uint c = 0xFF;\r\n\r\n    long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт. Представлен системным типом System.Int64\r\n    1\r\n    2\r\n    3\r\n    	\r\n    long a = -10;\r\n    long b = 0b101;\r\n    long c = 0xFF;\r\n\r\n    ulong: хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт. Представлен системным типом System.UInt64\r\n    1\r\n    2\r\n    3\r\n    	\r\n    ulong a = 10;\r\n    ulong b = 0b101;\r\n    ulong c = 0xFF;\r\n\r\n    float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта. Представлен системным типом System.Single\r\n\r\n    double: хранит число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта. Представлен системным типом System.Double\r\n\r\n    decimal: хранит десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10-28 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт. Представлен системным типом System.Decimal\r\n\r\n    char: хранит одиночный символ в кодировке Unicode и занимает 2 байта. Представлен системным типом System.Char. Этому типу соответствуют символьные литералы:\r\n    1\r\n    2\r\n    3\r\n    	\r\n\r\n\r\n    string: хранит набор символов Unicode. Представлен системным типом System.String. Этому типу соответствуют строковые литералы.\r\n    1\r\n    2\r\n    	\r\n    string hello = \"Hello\";\r\n    string word = \"world\";\r\n\r\n    object: может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе. Представлен системным типом System.Object, который является базовым для всех других типов и классов .NET.\r\n    1\r\n    2\r\n    3\r\n    	\r\n    object a = 22;\r\n    object b = 3.14;\r\n    object c = \"hello code\";\r\n\r\nНапример, определим несколько переменных разных типов и выведем их значения на консоль:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n	\r\nstring name = \"Tom\";\r\nint age = 33;\r\nbool isEmployed = false;\r\ndouble weight = 78.65;\r\n \r\nConsole.WriteLine($\"Имя: {name}\");\r\nConsole.WriteLine($\"Возраст: {age}\");\r\nConsole.WriteLine($\"Вес: {weight}\");\r\nConsole.WriteLine($\"Работает: {isEmployed}\");\r\n\r\nДля вывода данных на консоль здесь применяется интерполяция: перед строкой ставится знак $ и после этого мы можем вводить в строку в фигурных скобках значения переменных. Консольный вывод программы:\r\n\r\nИмя: Tom\r\nВозраст: 33\r\nВес: 78,65\r\nРаботает: False\r\n\r\nИспользование суффиксов\r\n\r\nПри присвоении значений надо иметь в виду следующую тонкость: все вещественные литералы (дробные числа) рассматриваются как значения типа double. И чтобы указать, что дробное число представляет тип float или тип decimal, необходимо к литералу добавлять суффикс: F/f - для float и M/m - для decimal.\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\nfloat a = 3.14F;\r\nfloat b = 30.6f;\r\n \r\ndecimal c = 1005.8M;\r\ndecimal d = 334.8m;\r\n\r\nПодобным образом все целочисленные литералы рассматриваются как значения типа int. Чтобы явным образом указать, что целочисленный литерал представляет значение типа uint, надо использовать суффикс U/u, для типа long - суффикс L/l, а для типа ulong - суффикс UL/ul:\r\n1\r\n2\r\n3\r\n	\r\nuint a = 10U;\r\nlong b = 20L;\r\nulong c = 30UL;\r\nИспользование системных типов\r\n\r\nВыше при перечислении всех базовых типов данных для каждого упоминался системный тип. Потому что название встроенного типа по сути представляет собой сокращенное обозначение системного типа. Например, следующие переменные будут эквивалентны по типу:\r\n1\r\n2\r\n	\r\nint a = 4;\r\nSystem.Int32 b = 4;\r\nНеявная типизация\r\n\r\nРанее мы явным образом указывали тип переменных, например, int x;. И компилятор при запуске уже знал, что x хранит целочисленное значение.\r\n\r\nОднако мы можем использовать и модель неявной типизации:\r\n1\r\n2\r\n	\r\nvar hello = \"Hell to World\";\r\nvar c = 20;\r\n\r\nДля неявной типизации вместо названия типа данных используется ключевое слово var. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения. Так как по умолчанию все целочисленные значения рассматриваются как значения типа int, то поэтому в итоге переменная c будет иметь тип int. Аналогично переменной hello присваивается строка, поэтому эта переменная будет иметь тип string\r\n\r\nЭти переменные подобны обычным, однако они имеют некоторые ограничения.\r\n\r\nВо-первых, мы не можем сначала объявить неявно типизируемую переменную, а затем инициализировать:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n	\r\n// этот код работает\r\nint a;\r\na = 20;\r\n \r\n// этот код не работает\r\nvar c;\r\nc= 20;\r\n\r\nВо-вторых, мы не можем указать в качестве значения неявно типизируемой переменной null:\r\n1\r\n2\r\n	\r\n// этот код не работает\r\nvar c=null;\r\n\r\nТак как значение null, то компилятор не сможет вывести тип данных.'),
(33, 'Консольный ввод-вывод', 'C#', 'https://i.imgur.com/IgLFOXN.png', 'Консольный вывод\r\n\r\nДля вывода информации на консоль мы уже использовали встроенный метод Console.WriteLine. То есть, если мы хотим вывести некоторую информацию на консоль, то нам надо передать ее в метод Console.WriteLine:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\nstring hello = \"Привет мир\";\r\nConsole.WriteLine(hello);\r\nConsole.WriteLine(\"Добро пожаловать в C#!\");\r\nConsole.WriteLine(\"Пока мир...\");\r\nConsole.WriteLine(24.5);\r\n\r\nКонсольный вывод:\r\n\r\nПривет мир!\r\nДобро пожаловать в C#!\r\nПока мир...\r\n24,5\r\n\r\nНередко возникает необходимость вывести на консоль в одной строке значения сразу нескольких переменных. В этом случае мы можем использовать прием, который называется интерполяцией:\r\n1\r\n2\r\n3\r\n4\r\n	\r\nstring name = \"Tom\";\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.WriteLine($\"Имя: {name}  Возраст: {age}  Рост: {height}м\");\r\n\r\nДля встраивания отдельных значений в выводимую на консоль строку используются фигурные скобки, в которые заключается встраиваемое значение. Это можем значение переменной ({name}) или более сложное выражение (например, операция сложения {4 + 7}). А перед всей строкой ставится знак доллара $.\r\n\r\nПри выводе на консоль вместо помещенных в фигурные скобки выражений будут выводиться их значения:\r\n\r\nИмя: Tom  Возраст: 34  Рост: 1,7м\r\n\r\nЕсть другой способ вывода на консоль сразу нескольких значений:\r\n1\r\n2\r\n3\r\n4\r\n	\r\nstring name = \"Tom\";\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.WriteLine(\"Имя: {0}  Возраст: {2}  Рост: {1}м\", name, height, age);\r\n\r\nЗдесь мы видим, что строка в Console.WriteLine содержит некие числа в фигурных скобках: {0}, {1}, {2}. Это плейсхолдеры, вместо которых при выводе строки на консоль будут подставляться некоторые значения. Подставляемые значения указываются после строки через запятую.\r\n\r\nПри этом важен порядок подобных плейсхолдеров. Например, в данном случае после строки первой указана переменная name, потом height и потом age. Поэтому значение переменной name будет вставляться вместо первого плейсхолдера - {0} (нумерация начинается с нуля), height - вместо {1}, а age - вместо {2}. Поэтому в итоге пи выводе на консоль строка\r\n1\r\n	\r\n\"Имя: {0}  Возраст: {2}  Рост: {1}м\"\r\n\r\nбудет заменена на\r\n1\r\n	\r\n\"Имя: Tom  Возраст: 34  Рост: 1,7м\"\r\nConsole.Write\r\n\r\nКроме Console.WriteLine() можно также использовать метод Console.Write(), он работает точно так же за тем исключением, что не добавляет переход на следующую строку, то есть последующий консольный вывод будет выводиться на той же строке.\r\n1\r\n2\r\n3\r\n4\r\n	\r\nstring name = \"Tom\";\r\nint age = 34;\r\ndouble height = 1.7;\r\nConsole.Write($\"Имя: {name}  Возраст: {age}  Рост: {height}м\");\r\nКонсольный ввод\r\n\r\nКроме вывода информации на консоль мы можем получать информацию с консоли. Для этого предназначен метод Console.ReadLine(). Он позволяет получить введенную строку.\r\n1\r\n2\r\n3\r\n	\r\nConsole.Write(\"Введите свое имя: \");\r\nstring? name = Console.ReadLine();\r\nConsole.WriteLine($\"Привет {name}\");\r\n\r\nВ данном случае все, что вводит пользователь, с помощью метода Console.ReadLine() передается в переменную name.\r\nПример работы программы:\r\n\r\nВведите свое имя: Том\r\nПривет Том\r\n\r\nОсобенностью метода Console.ReadLine() является то, что он может считать информацию с консоли только в виде строки. Кроме того, возможная ситуация, когда для метода Console.ReadLine не окажется доступных для считывания строк, то есть когда ему нечего считывать, он возвращаает значение null, то есть, грубо говоря, фактически отсутствие значения. И чтобы отразить эту ситуацию мы определяем переменную name, в которую получаем ввод с консоли, как переменную типа string?. Здесь string указывает, что переменная может хранить значения типа string, то есть строки. А знак вопроса ? указывает, что переменная также может хранить значение null, то есть по сути не иметь никакого значения. Далее мы более подробно разберем null и как с ним работать.\r\n\r\nОднако, может возникнуть вопрос, как нам быть, если, допустим, мы хотим ввести возраст в переменную типа int или другую информацию в переменные типа double или decimal? По умолчанию платформа .NET предоставляет ряд методов, которые позволяют преобразовать различные значения к типам int, double и т.д. Некоторые из этих методов:\r\n\r\n    Convert.ToInt32() (преобразует к типу int)\r\n\r\n    Convert.ToDouble() (преобразует к типу double)\r\n\r\n    Convert.ToDecimal() (преобразует к типу decimal)\r\n\r\nПример ввода значений:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n	\r\nConsole.Write(\"Введите имя: \");\r\nstring? name = Console.ReadLine();\r\n \r\nConsole.Write(\"Введите возраст: \");\r\nint age = Convert.ToInt32(Console.ReadLine());\r\n \r\nConsole.Write(\"Введите рост: \");\r\ndouble height = Convert.ToDouble(Console.ReadLine());\r\n \r\nConsole.Write(\"Введите размер зарплаты: \");\r\ndecimal salary = Convert.ToDecimal(Console.ReadLine());\r\n \r\nConsole.WriteLine($\"Имя: {name}  Возраст: {age}  Рост: {height}м  Зарплата: {salary}$\");\r\n\r\nПри вводе важно учитывать текущую операционную систему. В одних культурах разделителем между целой и дробной частью является точка (США, Великобритания...), в других - запятая (Россия, Германия...). Например, если текущая ОС - русскоязычная, значит, надо вводить дробные числа с разделителем запятой. Если локализация англоязычная, значит, разделителем целой и дробной части при вводе будет точка.\r\n\r\nПример работы программы:\r\n\r\nВведите имя: Том\r\nВведите возраст: 25\r\nВведите рост: 1,75\r\nВведите размер зарплаты: 300,67\r\nИмя: Том  Возраст: 25  Рост: 1,75м  Зарплата: 300,67$\r\n\r\n'),
(34, 'Арифметические операции языка C#', 'C#', 'https://i.imgur.com/B4abCj3.png', 'В C# используется большинство операций, которые применяются и в других языках программирования. Операции представляют определенные действия над операндами - участниками операции. В качестве операнда может выступать переменной или какое-либо значение (например, число). Операции бывают унарными (выполняются над одним операндом), бинарными - над двумя операндами и тернарными - выполняются над тремя операндами. Рассмотрим все виды операций.\r\n\r\nБинарные арифметические операции:\r\n\r\n    +\r\n\r\n    Операция сложения двух чисел:\r\n    1\r\n    2\r\n    	\r\n    int x = 10;\r\n    int z = x + 12; // 22\r\n\r\n    -\r\n\r\n    Операция вычитания двух чисел:\r\n    1\r\n    2\r\n    	\r\n    int x = 10;\r\n    int z = x - 6; // 4\r\n\r\n    *\r\n\r\n    Операция умножения двух чисел:\r\n    1\r\n    2\r\n    	\r\n    int x = 10;\r\n    int z = x * 5; // 50\r\n\r\n    /\r\n\r\n    операция деления двух чисел:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    	\r\n    int x = 10;\r\n    int z = x / 5; // 2\r\n     \r\n    double a = 10;\r\n    double b = 3;\r\n    double c = a / b; // 3.33333333\r\n\r\n    При делении стоит учитывать, что если оба операнда представляют целые числа, то результат также будет округляться до целого числа:\r\n    1\r\n    	\r\n    double z = 10 /  4; //результат равен 2\r\n\r\n    Несмотря на то, что результат операции в итоге помещается в переменную типа double, которая позволяет сохранить дробную часть, но в самой операции участвуют два литерала, которые по умолчанию рассматриваются как объекты int, то есть целые числа, и результат то же будет целочисленный.\r\n\r\n    Для выхода из этой ситуации необходимо определять литералы или переменные, участвующие в операции, именно как типы double или float:\r\n    1\r\n    	\r\n    double z = 10.0 /  4.0; //результат равен 2.5\r\n\r\n    %\r\n\r\n    Операция получение остатка от целочисленного деления двух чисел:\r\n    1\r\n    2\r\n    	\r\n    double x = 10.0;\r\n    double z = x % 4.0; //результат равен 2\r\n\r\nТакже есть ряд унарных операций, в которых принимает участие один операнд:\r\n\r\n    ++\r\n\r\n    Операция инкремента\r\n\r\n    Инкремент бывает префиксным: ++x - сначала значение переменной x увеличивается на 1, а потом ее значение возвращается в качестве результата операции.\r\n\r\n    И также существует постфиксный инкремент: x++ - сначала значение переменной x возвращается в качестве результата операции, а затем к нему прибавляется 1.\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    7\r\n    	\r\n    int x1 = 5;\r\n    int z1 = ++x1; // z1=6; x1=6\r\n    Console.WriteLine($\"{x1} - {z1}\");\r\n     \r\n    int x2 = 5;\r\n    int z2 = x2++; // z2=5; x2=6\r\n    Console.WriteLine($\"{x2} - {z2}\");\r\n\r\n    --\r\n\r\n    Операция декремента или уменьшения значения на единицу. Также существует префиксная форма декремента (--x) и постфиксная (x--).\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    7\r\n    	\r\n    int x1 = 5;\r\n    int z1 = --x1; // z1=4; x1=4\r\n    Console.WriteLine($\"{x1} - {z1}\");\r\n     \r\n    int x2 = 5;\r\n    int z2 = x2--; // z2=5; x2=4\r\n    Console.WriteLine($\"{x2} - {z2}\");\r\n\r\nПри выполнении сразу нескольких арифметических операций следует учитывать порядок их выполнения. Приоритет операций от наивысшего к низшему:\r\n\r\n    Инкремент, декремент\r\n\r\n    Умножение, деление, получение остатка\r\n\r\n    Сложение, вычитание\r\n\r\nДля изменения порядка следования операций применяются скобки.\r\n\r\nРассмотрим набор операций:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\nint a = 3;\r\nint b = 5;\r\nint c = 40;\r\nint d = c---b*a;    // a=3  b=5  c=39  d=25\r\nConsole.WriteLine($\"a={a}  b={b}  c={c}  d={d}\");\r\n\r\nЗдесь мы имеем дело с тремя операциями: декремент, вычитание и умножение. Сначала выполняется декремент переменной c, затем умножение b*a, и в конце вычитание. То есть фактически набор операций выглядел так:\r\n1\r\n	\r\nint d = (c--)-(b*a);\r\n\r\nНо с помощью скобок мы могли бы изменить порядок операций, например, следующим образом:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\nint a = 3;\r\nint b = 5;\r\nint c = 40;\r\nint d = (c-(--b))*a;    // a=3  b=4  c=40  d=108\r\nConsole.WriteLine($\"a={a}  b={b}  c={c}  d={d}\");\r\nАссоциативность операторов\r\n\r\nКак выше было отмечено, операции умножения и деления имеют один и тот же приоритет, но какой тогда результат будет в выражении:\r\n1\r\n	\r\nint x = 10 / 5 * 2;\r\n\r\nСтоит нам трактовать это выражение как (10 / 5) * 2 или как 10 / (5 * 2)? Ведь в зависимости от трактовки мы получим разные результаты.\r\n\r\nКогда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности есть два типа операторов:\r\n\r\n    Левоассоциативные операторы, которые выполняются слева направо\r\n\r\n    Правоассоциативные операторы, которые выполняются справа налево\r\n\r\nВсе арифметические операторы являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) * 2, то есть результатом будет 4.'),
(35, 'Поразрядные операции', 'C#', 'https://i.imgur.com/8IgMqNO.png', 'Особый класс операций представляют поразрядные операции. Они выполняются над отдельными разрядами числа. В этом плане числа рассматриваются в двоичном представлении, например, 2 в двоичном представлении 10 и имеет два разряда, число 7 - 111 и имеет три разряда.\r\nЛогические операции\r\n\r\n    &(логическое умножение)\r\n\r\n    Умножение производится поразрядно, и если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0. Например:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    7\r\n    	\r\n    int x1 = 2; //010\r\n     int y1 = 5;//101\r\n     Console.WriteLine(x1&y1); // выведет 0\r\n                 \r\n    int x2 = 4; //100\r\n    int y2 = 5; //101\r\n    Console.WriteLine(x2 & y2); // выведет 4\r\n\r\n    В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число 010, а 5 - 101. Поразрядно умножим числа (0*1, 1*0, 0*1) и в итоге получим 000.\r\n\r\n    Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, так же как и у числа 5, поэтому в итоге получим (1*1, 0*0, 0 *1) = 100, то есть число 4 в десятичном формате.\r\n\r\n    | (логическое сложение)\r\n\r\n    Похоже на логическое умножение, операция также производится по двоичным разрядам, но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица. Например:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    	\r\n    int x1 = 2; //010\r\n    int y1 = 5;//101\r\n    Console.WriteLine(x1|y1); // выведет 7 - 111\r\n    int x2 = 4; //100\r\n    int y2 = 5;//101\r\n    Console.WriteLine(x2 | y2); // выведет 5 - 101\r\n\r\n    ^ (логическое исключающее ИЛИ)\r\n\r\n    Также эту операцию называют XOR, нередко ее применяют для простого шифрования:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    5\r\n    6\r\n    7\r\n    8\r\n    	\r\n    int x = 45; // Значение, которое надо зашифровать - в двоичной форме 101101\r\n    int key = 102; //Пусть это будет ключ - в двоичной форме 1100110\r\n     \r\n    int encrypt = x ^ key; //Результатом будет число 1001011 или 75\r\n    Console.WriteLine($\"Зашифрованное число: {encrypt}\") ;\r\n     \r\n    int decrypt = encrypt ^ key; // Результатом будет исходное число 45\r\n    Console.WriteLine($\"Расшифрованное число: {decrypt}\");\r\n\r\n    Здесь опять же производятся поразрядные операции. Если у нас значения текущего разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0. Таким образом, мы получаем из 9^5 в качестве результата число 12. И чтобы расшифровать число, мы применяем ту же операцию к результату.\r\n\r\n    ~ (логическое отрицание или инверсия)\r\n\r\n    Еще одна поразрядная операция, которая инвертирует все разряды: если значение разряда равно 1, то оно становится равным нулю, и наоборот.\r\n    1\r\n    2\r\n    	\r\n    int x = 12;                 // 00001100\r\n    Console.WriteLine(~x);      // 11110011   или -13\r\n\r\nПредставление отрицательных чисел\r\n\r\nДля записи чисел со знаком в C# применяется дополнительный код (two’s complement), при котором старший разряд является знаковым. Если его значение равно 0, то число положительное, и его двоичное представление не отличается от представления беззнакового числа. Например, 0000 0001 в десятичной системе 1.\r\n\r\nЕсли старший разряд равен 1, то мы имеем дело с отрицательным числом. Например, 1111 1111 в десятичной системе представляет -1. Соответственно, 1111 0011 представляет -13.\r\n\r\nЧтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу:\r\n1\r\n2\r\n3\r\n4\r\n	\r\nint x = 12;\r\nint y = ~x;\r\ny += 1;\r\nConsole.WriteLine(y);   // -12\r\nTwo complement in C#\r\nОперации сдвига\r\n\r\nОперации сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.\r\n\r\n    x<<y - сдвигает число x влево на y разрядов. Например, 4<<1 сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, то есть в итоге получается 1000 или число 8 в десятичном представлении.\r\n\r\n    x>>y - сдвигает число x вправо на y разрядов. Например, 16>>1 сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.\r\n\r\nТаким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два. Поэтому подобную операцию можно использовать вместо непосредственного умножения или деления на два. Например:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n	\r\nint a = 16; // в двоичной форме 10000\r\nint b = 2; // в двоичной форме\r\nint c = a << b; // Сдвиг числа 10000 влево на 2 разряда, равно 1000000 или 64 в десятичной системе\r\n \r\nConsole.WriteLine($\"Зашифрованное число: {c}\") ;    // 64\r\n \r\nint d = a >> b; // Сдвиг числа 10000 вправо на 2 разряда, равно 100 или 4 в десятичной системе\r\nConsole.WriteLine($\"Зашифрованное число: {d}\");     // 4\r\n\r\nПри этом числа, которые участвую в операциях, необязательно должны быть кратны 2:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n	\r\nint a = 22; // в двоичной форме 10110\r\nint b = 2; // в двоичной форме\r\nint c = a << b; // Сдвиг числа 10110 влево на 2 разряда, равно 1011000 или 88 в десятичной системе\r\n \r\nConsole.WriteLine($\"Зашифрованное число: {c}\") ;    // 88\r\n \r\nint d = a >> b; // Сдвиг числа 10110 вправо на 2 разряда, равно 101 или 5 в десятичной системе\r\nConsole.WriteLine($\"Зашифрованное число: {d}\");     // 5\r\nПример практического применения операций\r\n\r\nМногие недооценивают поразрядные операции, не понимают, для чего они нужны. Тем не менее они могут помочь в решении ряда задач. Прежде всего они позволяют нам манипулировать данными на уровне отдельных битов. Один из примеров. У нас есть три числа, которые находятся в диапазоне от 0 до 3:\r\n1\r\n2\r\n3\r\n	\r\nint value1 = 3;  // 0b0000_0011\r\nint value2 = 2;  // 0b0000_0010\r\nint value3 = 1;  // 0b0000_0001\r\n\r\nМы знаем, что значения этих чисел не будут больше 3, и нам нужно эти данные максимально сжать. Мы можем три числа сохранить в одно число. И в этом нам помогут поразрядные операции.\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n	\r\nint value1 = 3;  // 0b0000_0011\r\nint value2 = 2;  // 0b0000_0010\r\nint value3 = 1;  // 0b0000_0001\r\nint result = 0b0000_0000;\r\n// сохраняем в result значения из value1\r\nresult = result | value1; // 0b0000_0011\r\n// сдвигаем разряды в result на 2 разряда влево\r\nresult = result << 2;   // 0b0000_1100\r\n// сохраняем в result значения из value2\r\nresult = result | value2;  // 0b0000_1110\r\n// сдвигаем разряды в result на 2 разряда влево\r\nresult = result << 2;   // 0b0011_1000\r\n// сохраняем в result значения из value3\r\nresult = result | value3;  // 0b0011_1001\r\n \r\nConsole.WriteLine(result);  // 57\r\n\r\nРазберем этот код. Сначала определяем все сохраняемые числа value1, value2, value3. Для хранения результата определена переменная result, которая по умолчанию равна 0. Для большей наглядности ей присвоено значение в бинарном формате:\r\n1\r\n	\r\nint result = 0b0000_0000;\r\n\r\nСохраняем первое число в result:\r\n1\r\n	\r\nresult = result | value1; // 0b0000_0011\r\n\r\nЗдесь мы имеем дело с логической операцией поразрядного сложения - если один из соответствующих разрядов равен 1, то результирующий разряд тоже будет равен 1. То есть фактически\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\n0b0000_0000\r\n+\r\n0b0000_0011\r\n=\r\n0b0000_0011\r\n\r\nИтак, первое число сохранили в result. Мы будем сохранять числа по порядку. То есть сначала в result будет идти первое число, затем второе и далее третье. Поэтому сдвигаем число result на два разряда влево (наши числа занимают в памяти не более двух разрядов):\r\n1\r\n	\r\nresult = result << 2;   // 0b0000_1100\r\n\r\nТо есть фактически\r\n1\r\n2\r\n	\r\n0b0000_0011 << 2 =\r\n0b0000_1100\r\n\r\nДалее повторяем логическую операцию сложения, сохраняем второе число:\r\n1\r\n	\r\nresult = result | value2;  // 0b0000_1110\r\n\r\nчто эквивалентно\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\n0b0000_1100\r\n+\r\n0b0000_0010\r\n=\r\n0b0000_1110\r\n\r\nДалее повторяем сдвиг на два разряда влево и сохраняем третье число. В итоге мы получим в двоичном представлении число 0b0011_1001. В десятично системе это число равно 57. Но это не имеет значения, потому что нам важны конкретные биты числа. Стоит отметить, что мы сохранили в одно число три числа, и в переменной result еще есть сводобное место. Причем в реальности не важно, сколько именно битов надо сохранить. В данном случае для примера сохраняем лишь два бита.\r\n\r\nДля восстановления данных прибегнем к обратному порядку:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n	\r\nresult = 0b0011_1001\r\n// обратное получение данных\r\nint newValue3 = result & 0b000_0011;\r\n// сдвигаем данные на 2 разряда вправо\r\nresult = result >> 2;\r\nint newValue2 = result & 0b000_0011;\r\n// сдвигаем данные на 2 разряда вправо\r\nresult = result >> 2;\r\nint newValue1 = result & 0b000_0011;\r\nConsole.WriteLine(newValue1);    // 3\r\nConsole.WriteLine(newValue2);   // 2\r\nConsole.WriteLine(newValue3);   // 1\r\n\r\nПолучаем числа в порядке, обратном тому, в котором они были сохранены. Поскольку мы знаем, что каждое сохраненное число занимает лишь два разряда, то по сути нам надо получить лишь последние два бита. Для этого применяем битовую маску 0b000_0011 и операцию логического умножения, которая возвращает 1, если каждый из двух соответствующих разрядов равен 1. То есть операция\r\n1\r\n	\r\nint newValue3 = result & 0b000_0011;\r\n\r\nэквивалентна\r\n1\r\n2\r\n3\r\n4\r\n5\r\n	\r\n0b0011_1001\r\n*\r\n0b0000_0011\r\n=\r\n0b0000_0001\r\n\r\nТаким образом, последнее число равно 0b0000_0001 или 1 в десятичной системе\r\n\r\nСтоит отметить, что если мы точно знаем структуру данных, то мы легко можем составить битовую маску, чтобы получить нужно число:\r\n1\r\n2\r\n3\r\n	\r\nresult = 0b0011_1001;\r\nint recreatedValue1 = (result & 0b0011_0000) >> 4;\r\nConsole.WriteLine(recreatedValue1);\r\n\r\nЗдесь получаем первое число, которое, как мы знаем, занимает в числе биты 4 и 5. Для этого применяем умножение на битовую маску 0b0011_0000. И затем сдвигаем число на 4 разряда вправо.\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n	\r\n0b0011_1001\r\n*\r\n0b0011_0000\r\n=\r\n0b0011_0000\r\n>> 4\r\n=\r\n0b0000_0011\r\n\r\nАналогично, если мы точно знаем структуру, по которой сохраняются данные, то мы могли бы сохранить данные сразу в нужное место в числе result:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n	\r\nint value1 = 3;  // 0b0000_0011\r\nint value2 = 2;  // 0b0000_0010\r\nint value3 = 1;  // 0b0000_0001\r\nint result = 0b0000_0000;\r\n// сохраняем в result значения из value1\r\nresult = result | (value1 << 4);\r\n// сохраняем в result значения из value2\r\nresult = result | (value2 << 2);\r\n// сохраняем в result значения из value3\r\nresult = result | value3;  // 0b0011_1001\r\n \r\nConsole.WriteLine(result);  // 57'),
(36, 'Операции присваивания', 'C#', 'https://i.imgur.com/QzV6jcf.jpg', 'Операции присвоения устанавливают значение. В операциях присвоения участвуют два операнда, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную\r\n\r\nКак и во многих других языках программирования, в C# имеется базовая операция присваивания =, которая присвоивает значение правого операнда левому операнду:\r\n1\r\n	\r\nint number = 23;\r\n\r\nЗдесь переменной number присваивается число 23. Переменная number представляет левый операнд, которому присваивается значение правого операнда, то есть числа 23.\r\n\r\nТакже можно выполнять множественно присвоение сразу нескольких переменным одновременно:\r\n1\r\n2\r\n	\r\nint a, b, c;\r\na = b = c = 34;\r\n\r\nСтоит отметить, что операции присвоения имеют низкий приоритет. И вначале будет вычисляться значение правого операнда и только потом будет идти присвоение этого значения левому операнду. Например:\r\n1\r\n2\r\n	\r\nint a, b, c;\r\na = b = c = 34 * 2 / 4; // 17\r\n\r\nСначала будет вычисляться выражение 34 * 2 / 4, затем полученное значение будет присвоено переменным.\r\n\r\nКроме базовой операции присвоения в C# есть еще ряд операций:\r\n\r\n    +=: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: выражение A += B равнозначно выражению A = A + B\r\n\r\n    -=: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B\r\n\r\n    *=: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B\r\n\r\n    /=: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B\r\n\r\n    %=: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B\r\n\r\n    &=: присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: A &= B эквивалентно A = A & B\r\n\r\n    |=: присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: A |= B эквивалентно A = A | B\r\n\r\n    ^=: присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: A ^= B эквивалентно A = A ^ B\r\n\r\n    <<=: присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A <<= B эквивалентно A = A << B\r\n\r\n    >>=: присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: A >>= B эквивалентно A = A >> B\r\n\r\nПрименение операций присвоения:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n	\r\nint a = 10;\r\na += 10;        // 20\r\na -= 4;         // 16\r\na *= 2;         // 32\r\na /= 8;         // 4\r\na <<= 4;      // 64\r\na >>= 2;      // 16\r\n\r\nОперации присвоения являются правоассоциативными, то есть выполняются справа налево. Например:\r\n1\r\n2\r\n3\r\n	\r\nint a = 8;\r\nint b = 6;\r\nint c = a += b -= 5;    // 9\r\n\r\nВ данном случае выполнение выражения будет идти следующим образом:\r\n\r\n    b -= 5 (6-5=1)\r\n\r\n    a += (b-=5) (8+1 = 9)\r\n\r\n    c = (a += (b-=5)) (c = 9)\r\n');
INSERT INTO `article` (`id`, `title`, `genre`, `image`, `description`) VALUES
(37, 'Условные выражения', 'C#', 'https://i.imgur.com/RoiTxsH.png', 'Отдельный набор операций представляет условные выражения. Такие операции возвращают логическое значение, то есть значение типа bool: true, если выражение истинно, и false, если выражение ложно. К подобным операциям относятся операции сравнения и логические операции.\r\nОперации сравнения\r\n\r\nВ операциях сравнения сравниваются два операнда и возвращается значение типа bool - true, если выражение верно, и false, если выражение неверно.\r\n\r\n    ==\r\n\r\n    Сравнивает два операнда на равенство. Если они равны, то операция возвращает true, если не равны, то возвращается false:\r\n    1\r\n    2\r\n    3\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a == b; // false\r\n\r\n    !=\r\n\r\n    Сравнивает два операнда и возвращает true, если операнды не равны, и false, если они равны.\r\n    1\r\n    2\r\n    3\r\n    4\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a != b;    // true\r\n    bool d = a!=10;     // false\r\n\r\n    <\r\n\r\n    Операция \"меньше чем\". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго:\r\n    1\r\n    2\r\n    3\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a < b; // false\r\n\r\n    >\r\n\r\n    Операция \"больше чем\". Сравнивает два операнда и возвращает true, если первый операнд больше второго, иначе возвращает false:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a > b;     // true\r\n    bool d = a > 25;    // false\r\n\r\n    <=\r\n\r\n    Операция \"меньше или равно\". Сравнивает два операнда и возвращает true, если первый операнд меньше или равен второму. Иначе возвращает false.\r\n    1\r\n    2\r\n    3\r\n    4\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a <= b;     // false\r\n    bool d = a <= 25;    // true\r\n\r\n    >=\r\n\r\n    Операция \"больше или равно\". Сравнивает два операнда и возвращает true, если первый операнд больше или равен второму, иначе возвращается false:\r\n    1\r\n    2\r\n    3\r\n    4\r\n    	\r\n    int a = 10;\r\n    int b = 4;\r\n    bool c = a >= b;     // true\r\n    bool d = a >= 25;    // false\r\n\r\nОперации <, > <=, >= имеют больший приоритет, чем == и !=.\r\nЛогические операции\r\n\r\nТакже в C# определены логические операторы, которые также возвращают значение типа bool. В качестве операндов они принимают значения типа bool. Как правило, применяются к отношениям и объединяют несколько операций сравнения.\r\n\r\n    |\r\n\r\n    Операция логического сложения или логическое ИЛИ. Возвращает true, если хотя бы один из операндов возвращает true.\r\n    1\r\n    2\r\n    	\r\n    bool x1 = (5 > 6) | (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true\r\n    bool x2 = (5 > 6) | (4 > 6); // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false\r\n\r\n    &\r\n\r\n    Операция логического умножения или логическое И. Возвращает true, если оба операнда одновременно равны true.\r\n    1\r\n    2\r\n    	\r\n    bool x1 = (5 > 6) & (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается false\r\n    bool x2 = (5 < 6) & (4 < 6); // 5 < 6 - true, 4 < 6 - true, поэтому возвращается true\r\n\r\n    ||\r\n\r\n    Операция логического сложения. Возвращает true, если хотя бы один из операндов возвращает true.\r\n    1\r\n    2\r\n    	\r\n    bool x1 = (5 > 6) || (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true\r\n    bool x2 = (5 > 6) || (4 > 6); // 5 > 6 - false, 4 > 6 - false, поэтому возвращается false\r\n\r\n    &&\r\n\r\n    Операция логического умножения. Возвращает true, если оба операнда одновременно равны true.\r\n    1\r\n    2\r\n    	\r\n    bool x1 = (5 > 6) && (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается false\r\n    bool x2 = (5 < 6) && (4 < 6); // 5 < 6 - true, 4 < 6 - true, поэтому возвращается true\r\n\r\n    !\r\n\r\n    Операция логического отрицания. Производится над одним операндом и возвращает true, если операнд равен false. Если операнд равен true, то операция возвращает false:\r\n    1\r\n    2\r\n    	\r\n    bool a = true;\r\n    bool b = !a;    // false\r\n\r\n    ^\r\n\r\n    Операция исключающего ИЛИ. Возвращает true, если либо первый, либо второй операнд (но не одновременно) равны true, иначе возвращает false\r\n    1\r\n    2\r\n    	\r\n    bool x5 = (5 > 6) ^ (4 < 6); // 5 > 6 - false, 4 < 6 - true, поэтому возвращается true\r\n    bool x6 = (50 > 6) ^ (4 / 2 < 3); // 50 > 6 - true, 4/2 < 3 - true, поэтому возвращается false\r\n\r\nЗдесь у нас две пары операций | и || (а также & и &&) выполняют похожие действия, однако же они не равнозначны.\r\n\r\nВ выражении z=x|y; будут вычисляться оба значения - x и y.\r\n\r\nВ выражении же z=x||y; сначала будет вычисляться значение x, и если оно равно true, то вычисление значения y уже смысла не имеет, так как у нас в любом случае уже z будет равно true. Значение y будет вычисляться только в том случае, если x равно false\r\n\r\nТо же самое касается пары операций &/&&. В выражении z=x&y; будут вычисляться оба значения - x и y.\r\n\r\nВ выражении же z=x&&y; сначала будет вычисляться значение x, и если оно равно false, то вычисление значения y уже смысла не имеет, так как у нас в любом случае уже z будет равно false. Значение y будет вычисляться только в том случае, если x равно true\r\n\r\nПоэтому операции || и && более удобны в вычислениях, так как позволяют сократить время на вычисление значения выражения, и тем самым повышают производительность. А операции | и & больше подходят для выполнения поразрядных операций над числами.'),
(38, 'Преобразования базовых типов данных', 'C#', 'https://i.imgur.com/1hkoYZE.png', 'При рассмотрении типов данных указывалось, какие значения может иметь тот или иной тип и сколько байт памяти он может занимать. В прошлой теме были расмотрены арифметические операции. Теперь применим операцию сложения к данным разных типов:\r\n1\r\n2\r\n	\r\nbyte a = 4;\r\nint b = a + 70;\r\n\r\nРезультатом операции вполне справедливо является число 74, как и ожидается.\r\n\r\nНо теперь попробуем применить сложение к двум объектам типа byte:\r\n1\r\n2\r\n	\r\nbyte a = 4;\r\nbyte b = a + 70;  // ошибка\r\n\r\nЗдесь поменялся только тип переменной, которая получает результат сложения - с int на byte. Однако при попытке скомпилировать программу мы получим ошибку на этапе компиляции. И если мы работаем в Visual Studio, среда подчеркнет вторую строку красной волнистой линией, указывая, что в ней ошибка.\r\n\r\nПри операциях мы должны учитывать диапазон значений, которые может хранить тот или иной тип. Но в данном случае число 74, которое мы ожидаем получить, вполне укладывается в диапазон значений типа byte, тем не менее мы получаем ошибку.\r\n\r\nДело в том, что операция сложения (да и вычитания) возвращает значение типа int, если в операции участвуют целочисленные типы данных с разрядностью меньше или равно int (то есть типы byte, short, int). Поэтому результатом операции a + 70 будет объект, который имеет длину в памяти 4 байта. Затем этот объект мы пытаемся присвоить переменной b, которая имеет тип byte и в памяти занимает 1 байт.\r\n\r\nИ чтобы выйти из этой ситуации, необходимо применить операцию преобразования типов. Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение:\r\n1\r\n	\r\n(тип_данных_в_который_надо_преобразовать)значение_для_преобразования;\r\n\r\nТак, изменим предыдущий пример, применив операцию преобразования типов:\r\n1\r\n2\r\n	\r\nbyte a = 4;\r\nbyte b = (byte)(a + 70);\r\nСужающие и расширяющие преобразования\r\n\r\nПреобразования могут быть сужающие (narrowing) и расширяющие (widening). Расширяющие преобразования расширяют размер объекта в памяти. Например:\r\n1\r\n2\r\n	\r\nbyte a = 4;             // 0000100\r\nushort b = a;   // 000000000000100\r\n\r\nВ данном случае переменной типа ushort присваивается значение типа byte. Тип byte занимает 1 байт (8 бит), и значение переменной a в двоичном виде можно представить как:\r\n1\r\n	\r\n00000100\r\n\r\nЗначение типа ushort занимает 2 байта (16 бит). И при присвоении переменной b значение переменной a расширяется до 2 байт\r\n1\r\n	\r\n0000000000000100\r\n\r\nТо есть значение, которое занимает 8 бит, расширяется до 16 бит.\r\n\r\nСужающие преобразования, наоборот, сужают значение до типа меньшей разядности. Во втором листинге статьи мы как раз имели дело с сужающими преобразованиями:\r\n1\r\n2\r\n	\r\nushort a = 4;\r\nbyte b = (byte) a;\r\n\r\nЗдесь переменной b, которая занимает 8 бит, присваивается значение ushort, которое занимает 16 бит. То есть из 0000000000000100 получаем 00000100. Таким образом, значение сужается с 16 бит (2 байт) до 8 бит (1 байт).\r\nЯвные и неявные преобразования\r\nНеявные преобразования\r\n\r\nВ случае с расширяющими преобразованиями компилятор за нас выполнял все преобразования данных, то есть преобразования были неявными (implicit conversion). Такие преобразования не вызывают каких-то затруднений. Тем не менее стоит сказать пару слов об общей механике подобных преобразований.\r\n\r\nЕсли производится преобразование от безнакового типа меньшей разрядности к безнаковому типу большой разрядности, то добавляются дополнительные биты, которые имеют значени 0. Это называется дополнение нулями или zero extension.\r\n1\r\n2\r\n	\r\nbyte a = 4;             // 0000100\r\nushort b = a;   // 000000000000100\r\n\r\nЕсли производится преобразование к знаковому типу, то битовое представление дополняется нулями, если число положительное, и единицами, если число отрицательное. Последний разряд числа содержит знаковый бит - 0 для положительных и 1 для отрицательных чисел. При расширении в добавленные разряды компируется знаковый бит.\r\n\r\nРассмотрим преобразование положительного числа:\r\n1\r\n2\r\n	\r\nsbyte a = 4;            // 0000100\r\nshort b = a;    // 000000000000100\r\nSing bit in conversions in c#\r\n\r\nПреобразование отрицательного числа:\r\n1\r\n2\r\n	\r\nsbyte a = -4;           // 1111100\r\nshort b = a;    // 111111111111100\r\nSing bit negative number in conversions in c#\r\nЯвные преобразования\r\n\r\nПри явных преобразованиях (explicit conversion) мы сами должны применить операцию преобразования (операция ()). Суть операции преобразования типов состоит в том, что перед значением указывается в скобках тип, к которому надо привести данное значение:\r\n1\r\n2\r\n3\r\n	\r\nint a = 4;\r\nint b = 6;\r\nbyte c = (byte)(a+b);\r\n\r\nРасширяющие преобразования от типа с меньшей разрядностью к типу с большей разрядностью компилятор проводит неявно. Это могут быть следующие цепочки преобразований:\r\n\r\nbyte -> short -> int -> long -> decimal\r\n\r\nint -> double\r\n\r\nshort -> float -> double\r\n\r\nchar -> int\r\n\r\nВсе безопасные автоматические преобразования можно описать следующей таблицей:\r\n\r\nТип\r\n	\r\n\r\nВ какие типы безопасно преобразуется\r\n\r\nbyte\r\n	\r\n\r\nshort, ushort, int, uint, long, ulong, float, double, decimal\r\n\r\nsbyte\r\n	\r\n\r\nshort, int, long, float, double, decimal\r\n\r\nshort\r\n	\r\n\r\nint, long, float, double, decimal\r\n\r\nushort\r\n	\r\n\r\nint, uint, long, ulong, float, double, decimal\r\n\r\nint\r\n	\r\n\r\nlong, float, double, decimal\r\n\r\nuint\r\n	\r\n\r\nlong, ulong, float, double, decimal\r\n\r\nlong\r\n	\r\n\r\nfloat, double, decimal\r\n\r\nulong\r\n	\r\n\r\nfloat, double, decimal\r\n\r\nfloat\r\n	\r\n\r\ndouble\r\n\r\nchar\r\n	\r\n\r\nushort, int, uint, long, ulong, float, double, decimal\r\nПреобразования типов в c#\r\n\r\nВ остальных случаях следует использовать явные преобразования типов.\r\n\r\nТакже следует отметить, что несмотря на то, что и double, и decimal могут хранить дробные данные, а decimal имеет большую разрядность, чем double, но все равно значение double нужно явно приводить к типу decimal:\r\n1\r\n2\r\n	\r\ndouble a = 4.0;\r\ndecimal b = (decimal)a;\r\nПотеря данных и ключевое слово checked\r\n\r\nРассмотрим другую ситуацию, что будет, например, в следующем случае:\r\n1\r\n2\r\n3\r\n4\r\n	\r\nint a = 33;\r\nint b = 600;\r\nbyte c = (byte)(a+b);\r\nConsole.WriteLine(c);   // 121\r\n\r\nРезультатом будет число 121, так число 633 не попадает в допустимый диапазон для типа byte, и старшие биты будут усекаться. В итоге получится число 121. Поэтому при преобразованиях надо это учитывать. И мы в данном случае можем либо взять такие числа a и b, которые в сумме дадут число не больше 255, либо мы можем выбрать вместо byte другой тип данных, например, int.\r\n\r\nОднако ситуации разные могут быть. Мы можем точно не знать, какие значения будут иметь числа a и b. И чтобы избежать подобных ситуаций, в c# имеется ключевое слово checked:\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n	\r\ntry\r\n{\r\n    int a = 33;\r\n    int b = 600;\r\n    byte c = checked((byte)(a + b));\r\n    Console.WriteLine(c);\r\n}\r\ncatch (OverflowException ex)\r\n{\r\n    Console.WriteLine(ex.Message);\r\n}\r\n\r\nПри использовании ключевого слова checked приложение выбрасывает исключение о переполнении. Поэтому для его обработки в данном случае используется конструкция try...catch. Подробнее данную конструкцию и обработку исключений мы рассмотрим позже, а пока надо знать, что в блок try мы включаем действия, в которых может потенциально возникнуть ошибка, а в блоке catch обрабатываем ошибку.');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `article`
--
ALTER TABLE `article`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `article`
--
ALTER TABLE `article`
  MODIFY `id` int NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=39;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
